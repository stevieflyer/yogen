I'm going to be showing you how to create this to-do list VS Code extension, which may look simple, but this code base is the foundation that I use to create VS Code Tinder. And it has basically all the important topics that you need to know to build something out like that. So starting off, I'm going to be showing you how to use web views in VS Code. This entire thing is a web view. This allows you to stick pretty much anything that you want to inside of VS Code and actually build out the web views. I like to use a front-end framework. In this video, I'm going to be showing you how to use Felt, which is what I've been using for my past two extensions and really liking it. But as you're gonna see, you can use any front framework you want as long as it spits out a JavaScript file at the end. After that, we'll implement GitHub OAuth. So like I can log out here, and I can press this button here to log in with GitHub, and I'm already kind of authenticated with GitHub so it just, you know, automatically says we're auth. And then we go in. But if say I wasn't logged in with GitHub, it would have me type in my GitHub credentials, and then it knows who I am based on my GitHub profile, so it says hello bin there, right? And then after that, we're going to integrate with an API. Well, we have to kind of integrate with an API to use GitHub OAuth2, so we're going to set up a Node.js server where we store stuff in a database and interact with that for our web view so we can actually persist data. Right, this data doesn't go away after I refresh or whatever. If that sounds interesting to you and you want to build the next big VS Code extension, continue watching. Also, by the way, all the code for this is on GitHub. I'll put a link in the description if you want to just look at that or if you get stuck in the middle, want to check that out. Also, there'll be a link to my Discord if you want to come and ask questions or talk to other people that have gone through the tutorial. With that said, enjoy the tutorial. We're going to start by following the getting started that VS Code has for creating your first extension. So you're going to want to come to this URL, and I'll put a link to this in the description. And the first thing that we're going to do is just copy this code right here. And then you're going to go to your terminal, and you're going to paste it, and we're going to run it. So you're going to need Node.js installed on your computer to be able to run npm. And then this is the g flag which installs this globally and then we're going to be able to run this yo command, which we're going to do next. Yo code and this is going to create a project for us. All right, so finish installing so I'm going to run yo code here and then we're just going to fill out the stuff that it asks us. So we're going to be creating a new TypeScript extension, so I'm going to select this first one here. You can do this in JavaScript, but I would recommend following along in TypeScript. That's what I'm going to be using and I'll be showing you along the way if you're new to TypeScript the things that you need to know. And I'm going to call my extension VS To Do, and I'm just going to keep the default. And what's the description? Keeping track of stuff and initialize a Git repository, sure. Bundle the source code with Webpack. Actually, we're going to hit yes for this, uh, reason for that is we're gonna I wanna show this at the end, because this is good when we deploy this to production. And I'm going to go ahead and pick Yarn, but you can pick npm if you want. Actually, you know what, let's pick npm today. I'm feeling npm. When that's done, you should have a new folder with the name of your extension. So I called mine VS To Do, so I have that there, and I'm just going to open it up in VS Code. So I have the CLI for VS Code, or it's at least installed in my path so I can just run code and then the name of the folder and it's going to open it up. And now I have it open in VS Code. You can also just open it regularly by going up here and open and all that jazz. Okay, so this is our first extension, the boilerplate for it. The main place we're going to be doing stuff in is source and extension. I'm going to delete tests. We're not going to worry about tests for this tutorial. And let's just zoom out actually a little bit, maybe once. All right, so they got a console log here. I'm gonna be showing you where you can see the console logs for things. Why don't we just press F5 first and that'll launch the debugger and actually launch our extension. So what I like to do, and it takes a second to build so we'll give it a minute, the specified task cannot be tracked. Oh yeah, um, configure task. I don't know, compile oh wants me to come and configure it. This is what I get for picking Webpack

These are the tasks that it runs before it actually launches the extension, and so in our case it builds using webpack. Now maybe there's a good way to set this up, but we literally just ran the code that we got from the boilerplate and it's already barking at us. So what I like to do is just not actually use this at all, and I will just remove all the tasks that it runs. Instead what I'll do is I will just go to my terminal. Is it already running? I'm just going to control c out of that, and I will just run it manually myself. So, if we go back to our package.json and we see scripts here, you'll notice one called watch. And this just runs webpack and we're going to say watch. This is basically going to take our source code here, which is just the extension, and it's going to compile it into this dist folder. You can click it here and webpack just does its thing where it transpiles all your code. Right, so it takes our extension.ts and turns it into a JavaScript file and it looks like this. Alright. And then after that, we're ready to execute the code. You just press f5. I ran to run this every time. Select a build test. There's no default build task. Maybe I need to go into my launch pre-launch task default build. Yeah, let's kill that. Now, f5 perfect. And now when we press f5, it's just going to launch our extension and then we're good to go. I forgot what our extension even does by default. I think it's just a yeah, it's just a command. So you can see here that it's registering a command called hello world. So if I do command shift p or control shift p if you're on a Windows computer and then here you can see that there's this little arrow here that's how you get the this is like the command prompt window and then you put a carrot there and then carrot lets you do commands in VS Code. So we're going to be running commands. This is also useful even if you're not you know doing extensions and if we search for hello world, this is actually going to be ours and we can just run it. It says hello world from VS to do on the bottom right here. So now if we wanted to change this, I'm just going to get rid of these comments because they're kind of annoying me. There we go, just a little bit easier to see the code and now here I am going to change the message. I'm just going to say hello from VS to do. Now if I come back over here and rerun this. Right, hello world from VS to do. It didn't change the text right. So what you need to do is actually reload this window every time you make a change over here. So to reload it, I can open up command prompt. And by the way you're going to want to get comfortable like opening up this command palette so command shift p is going to be your friend here and we're going to reload the developer window so you can run this right here. Right, now it's kind of tedious to open that up and do that every single time so I recommend using the shortcut to command r or I assume it's let's see reload if you just hover it'll show you on the right what the the shortcut is if it's different on mac I mean on windows probably is um. So that's we're going to use and then we can go and run our hello world command and you'll notice the text has changed. Alright, so that is kind of the basics of how we are going to make changes and do things. We're going to go over more of what's going on here next but basically we are going to start our extension. Compile it using webpack by running yarn watch. I said I was going to use npm there you go npm run watch. Alright and then my launch.json we just cleaned out you're never going to have to touch that again. We just press f5 and that's going to launch the actual extension over here and that as you noticed if I stop this all it does when I press f5 is create a new VS Code window that I can do test things in so it you know this is just I actually have I think a thing open but I can just go and open whatever project I want in here right this is just a normal VS Code window that also has our extension load in it so we can run our stuff. So it lets you test it on real things. Okay so let's add our own custom command now. So you'll notice a few parts about this. The first thing is this register command function that we can call. So I'm going to come down here and say VS Code dot commands dot register command. And here you'll notice kind of like the syntax for it is we prefix it with the name of our extension so I'm going to follow that and then here I'm going to say ask a question. This is what I'm going to call it. I mean that's a crappy name but I'm just going to actually do ask question that way it's a little bit less cracky and then I'm gonna have a function here. So this is what's the logic that's going to get run whenever this gets called

But the nice thing about this message or one of the cool things you could do is also get input from the user. So, I could say how was your day? You are day, no. And then here I can say good, bad, and then you'll notice that context.subscriptions.push this disposable thing. All this does is basically it's getting the return value from this, and the purpose of this is for VS Code to be able to dispose of this listener whenever it's done. And usually what I will do is not create this like variable and I will just wrap this. So, you see I just wrapped the push, and I put this inside, and that just makes it like a little bit simpler, and I'm going to do the same thing here because you don't really need the intermediate variable but you may, you can add that if it helps you. All right, so I added this but this is not the only thing you need to add when you add a command. If you also go into the package.json, you need to tell VS Code all the things that you add in your extension. So, we are going to tell it the command that we added here. So contributes commands you should see in your package.json and we're going to add it there. And you can see the previous command that they had there and here I'm going to say ask question, and so this string should match what you put here, and then here the title this is what's actually going to show up when a user, you know, types here. So, you see how it says hello world there and insead has developer colon that you can also prefix some of this stuff. I think it's called group, okay no it's not so I just did control space and gave me some autocompletion looks like it's called category. And so what I'll usually do is I'll actually say VS to do here that way they know that this is coming this command is coming from the VS to do extension and you'll see what this looks like in a second, and then here I guess in this case we're really answering a question but whatever. All right, so that's the I guess metadata and then we need to tell VS Code to actually activate it and that's the activation events here we're going to copy this and then just add our ask question. All right, so I made changes so I need to come over here and I need to reload it. All right, so command r for me and I'm just going to run this so command shift p to open up the palette and I'm going to go to my ask question so you'll notice how it has the category in front here so that's pretty handy I'm gonna press this so you can see it now says how's your day and I can press good or bad so my day was pretty good so I'm gonna press good now you may wanna get actually some you know response and actually do something with the data so if you hover over this I can see the type of this and and we see right here that it says it's a venable so the venables are basically just promises but they have special names there may be something different but I don't I actually don't know what's different about them I just treat them as promises so what I do here is I can make this as asynchronous and I can say the answer is equal to and I can await the response from this and you'll notice it's going to give us a string or undefined and I believe undefined comes if like the user clicks out so if I ask a question and I click the x for example I believe that gives you undefined and so here I'm just going to say you know if answer was equal too bad maybe we show an informational message right so paste that here sorry to hear that otherwise we're just going to console log answer okay so come over here and reload our extension and again I should probably mention this earlier but I'm just going to keep the mpm watch command running the entire tutorial so it's just going to basically recompile our code as I'm typing here and then if your window ever closes you know or you know guess you stop it manually just come here and press f5 to reopen it. All right so I'm going to ask a question and again I relaunched it but make sure to always refresh whenever you make a change. All right so I'm going to ask a question here and you'll notice it takes like a second there and need to activate the extension. All right so that I'm going to say I had a bad day and we could see that awesome and now let's do a good day right and you're wondering where did the console log go so if you come back over here and you hit control till day it'll toggle the terminal I believe if you also go terminal new terminal you can grab it but again control tilde is the shortcut that I use and you go to debug console you can actually see the console locks so if I see the object here it actually says answer good and so if you need to see console logs when you're doing things that is how you see it

So, if you go to Google and just type VS Code WebView, two links will come up. Number one, you can click the first one. This WebView API if you want to read through and follow along with this. Otherwise, this is a really good repository right here on GitHub. So, this is under the VS Code extension samples. It's the WebView sample you can follow along with this, but it has some extra stuff that we rip out. So, I'm going to show you something else we're going to do, but I wanted to mention this repository. This has a ton of examples, and this is pretty much how I learned all my VS Code knowledge. Right here is just going through these projects and copying pasting stuff. So, if you get stuck on how to do something in VS Code later that we don't cover in this tutorial, I highly recommend coming to here and seeing if one of these GitHub projects has it. All right, so what we're going to do is go over to GitHub.com/binaward/fascinder, and we're just going to grab one of my components here. So, I'm going to press go to file, and we're going to grab what's what I call provider. And all it is is if I go back to my WebView while that's loading, if we go to source extension, we're going to create a panel. They call it a cat coding panel, and there's a few extra things. So, I'm going to get a slimmed down version. Come on, go to file. Okay, um, provider, and I want, actually, did I call it? I think I'll call it something else. Yes, swiper panel is what I want. All right, and you can just go to this URL too. I'll probably put this in the description if I remember, and I'm going to copy this, copy, and I'm going to come into VS Code here, and I like to just stick this in a new file here. So, I'm just going to call this a hello world panel and put.ts, and I'm going to paste it in. Now, this also has a few things that we do not need. So, this entire top part we don't need for now, and I'm going to rename this class here to be hello world panel, and you'll notice that we use that kind of everywhere. So, actually, I'm going to Ctrl+Z, and if you press F2, you can refactor and rename in all the places, so I'm going to do that. Hello world. All right, view type here, this is just a string of the name, so I'm just going to call this hello world, and then let's scroll down. See the errors all this is fine. Update did receive message. All right, we're going to be getting into um on dead receive message later, but this is basically a switch statement that we're going to use to communicate, and I'm just going to delete some of the stuff I have here. Set window info, I kind of like my on info on errors, I'm going to keep those, and we're going to talk more about that in a second. I'm going to just comment out the tokens because we're probably going to do something like that later. All right, so this is what it looks like now in the update function. The error should be gone from there. All right, so, this function right here is important. So, this is how it gets basically the files for the WebView that actually renders. So, you notice here it is getting a file called swiper.js from the app directory. We're going to talk more about compiling this using Svelte in a second, but we're just going to get vanilla JavaScript working first. All right, so there's two basically CSS files that VS Code gives us or they recommend from just their cat example that we're going to use. So, back at the cat example, if you go to source, actually it's in the WebView sample media, we're going to copy the reset.css and the VSCode.css, and all this does is it makes the panel look like VS Code. So, if I create a new folder here called media, and actually I want to show you what it looks like with and without it. So, reset.css and we'll paste it in and grab VSCode.css as well. All right, so I'm going to show you what it looks like if we just create a panel and we don't do any scripts at all. So, I'm going to comment out the CSS one, and I'm going to comment out this one as well. So, we don't need this part right here either. So, basically this entire stuff before the return statement, we're just going to comment out and we're going to come back to it. And do I want a nonce? Actually, you can keep the nonce, I guess, because we're going to need that. So, get nonces, this is just, actually we're going to grab that as well. It's actually inside of WebView sample source at the bottom here. Get nonces, and I like to stick that in another file because we're going to use this a couple times. This just creates a unique ID, basically that's what that's doing. And I'm going to import, I like to import by just hitting command and then period, may do control period on Windows, and hit import. You could also put your cursor at the end here and control space, those are two options to auto import stuff. All right, so, API base URL, we do not have yet. I'm just going to remove this

So it just has image source here, and we do not have these links yet. I kind of want to just comment this out because we're going to have it. Um, you know what? I'm just going to set it to an empty string there and then I'll just remember what I need to do and we can remove this. We're not going to. This is how you can actually inject variables into the web view. We're going to do that a little bit. We don't need it right now, and we don't need this one either, so it's just scripture, okay? All right. So this is basically just an HTML document that's going to be our web view, and in the body here, why don't we just do an h1 that says hello world, right? And we'll save that, and this looks good. So we're going to go into our extension, and maybe we're going to activate this panel just when we call hello world here, instead of showing an informational message. So I'm going to say hello world panel dot create or show, and you'll notice here. So, by the way, that's something I haven't really mentioned yet since we're using TypeScript. If you're new to that, if you're unsure about types, you just hover over and it's going to tell you types. What I mean by that is here, I can see that this function here takes one parameter called extension yuri and the type of that is a VS Code Yuri. All right. So I know what I need to pass in now. Also, extension yuri, this is something that comes from the context. So I didn't mention this yet, but this is the activate function and this basically it's called when your extension first gets set up and this is basically where you initialize everything and so we just need to pass in context dot yuri and the extensionary we can pass that in. All right. And now let's come over here, reload, of course, and now let's run the hello world and see what happens. Nice, so it took a second to activate, then it got it, and this is what it looks like. I'm actually surprised this is black, I was expecting it to be like white. Let me display like an input field for you, but notice how we have like a new window here that we created. This is just a web view, basically sitting inside VS Code, and this is a regular like tab, right? I can switch between the tabs and whatnot. All right. So that's awesome and what I want to do now is just go to my hello world panel and I can treat this just like HTML, right? So I can do whatever I want here, do an input tag and uh, so yep, we're going to have to refresh every single time, and then we're going to come here and we're going to type hello world. So there's a little bit of an iteration cycle there but we're going to do something that makes that better in a second. All right. Notice how this is just an ugly white box and we got like an orange around it, right? So VS Code has CSS just default that styles some things. Also for the button, let me show you the button, those are nice too. So do a button tag in our panel here, we'll reload it and redo hello world. All right. So buttons are ugly right now, now if I come back up here, do our reset style, get this. So I guess I'm doing like two parts here and I actually don't know why I didn't just mash this into a single variable, like actually what I want to do here is just take this part and put it here, that way I don't have so many just random variables floating around. I think it makes just a little bit simpler in my opinion, and I actually did that for the CSS yuri. All right. This thing doesn't exist yet. All right. So all this is doing is telling VS Code the path to your CSS file. So you'll notice how it says the extension yuri, this is basically your base path, and then the media, that's the name of our folder right here and this is the name of the file. So this is basically just a URL to these reset and the VS Code files that we have there, and then all we're going to tell it is to load those CSS files using a link and we just stick the styles reset here and then we can do two of them, right? So now I'm also going to get the styles main and come back over here reload and run hello world and now it should be a little bit prettier when this loads. Awesome. So you notice how now it feels more like VS Code, we got dark inputs, we got cooler buttons. You still need to do a little bit styling yourself but at least this is good defaults. Now we can also load some JavaScript in here, so let me show you that. So if we come back over here and we come to the section here, you can see I was kind of like loading a script yuri from before. I'm going to bring that back in here and it's doing the exact same thing right as our CSS files but instead it's pointing at a JavaScript file. In this case I had like a compiled swiper.js, we're going to get into some compiled JavaScript in a second but let me just show you with vanilla JavaScript so I'm going to just stick this in my media folder and I'm just going to call it main.js. All right

Dot js file and I actually can't write vanilla JavaScript to save my life. So I'm just going to come to the example of the cats in the webview sample and copy their main.js. All right, and we'll copy this, paste it here, and I don't need half of this stuff but I just wanted to copy their document.element id thing because I forgot how that worked. All right, this VS Code thing allows us to kind of do some VS Code things and communicate with the VS Code extension itself. We're going to get into that later. Um, but right now we are going to just basically update the DOM, right? So I don't know, make my button. I actually don't even know what I'm doing. I think I can just say button.enter text is equal to hello from JavaScript. Let's try that, see if that does anything. And then my panel over here, I need to load that. So I'm going to grab this script, paste it at the bottom here. I just copied the location that VS Code originally put this and the source is going to be whatever I called it, script yuri. All right, now remember every time that I edit this file, an extension file, I then have to come and reload. But every time that I change a JavaScript file, for example, all I have to do is close and reopen the webview, which we're going to see in a second here. Okay, so hello world, I see it. Dude, did my JavaScript not get executed? It just shows it here, maybe that's not how you do things. But one thing I'll show you and this is how you can debug is if I open the panel and I say open webview developer tools, you can see cannot set the property inner text of null. Okay, so my JavaScript is running, I just don't know how do you do vanilla JavaScript, all right? So that's that. If I come over to my main.js, maybe we just do a console log hello there from JavaScript, save it, so again I do not need to reload this panel right because I only changed the JavaScript file. What I need to do is just close this and recall it, and then it'll be here, and I then want to reopen my webview developer tools, that's the other annoying thing, this closes every time this panel closes. But don't worry, I've got something for you that's going to make your life way better in a second. And you can see it says hello from JavaScript. And also, by the way, we have element picker, this is full developer tools here. All right, so I can click here and I can see all the things, right? And I can do stuff and I can see the URLs it's using. I can also see that VS Code is giving us a ton of CSS variables right, so this is what we can actually use for color scheming and whatnot, and they also just give us some default styling, a lot of stuff, and that's pretty much all I used for my stuff. Now you could continue to write the entire webview for your extension in vanilla JavaScript, but that's something I'm just not remotely interested in at all. So instead what I like to use is a JavaScript framework, and then basically just compile or transpile that JavaScript framework code into a JavaScript file that we then just in our hello world panel, we import. Right, so down here, you know how we were loading a main.js file, instead we were just going to basically load a compiled JavaScript file from our JavaScript framework. Now what I'm going to be using in this tutorial is Svelte, that's what I've been using for my past extensions and I've been enjoying it and it's pretty lightweight. So that's what we're going to be using as well, but you can pretty much use any JavaScript framework as long as you get a JS file at the end that you can use. So we're going to be setting that up now, and we're going to start by just going back over to the cinder because there's going to be a little bit of config we need. So I'm going to go actually to is it the extension level yeah, and I'm going to grab the rollup.config.js. So rollup is a program kind of like webpack that is going to turn our Svelte code into JavaScript code that is compiled. All right, so create a new file here rollup.config.js, and I'm just going to paste that entire file in. Now most of this is just copy pasting exactly from Svelte's getting started boilerplate with one exception which I'll talk about right here. Right, so you notice how here I'm using fs, this is just the node module for the file system and I'm reading a directory here and the directory that I'm reading is one called svelt stuff and inside of that pages

To be the root level of the application. So here, I'm going to create a hello world. Actually, how do I want to capitalize this? I guess just like this, hello world.ts is what I'm sticking here. All right, and as I add more pages, it's just going to automatically compile each one so I don't have to come here and touch stuff. Um, so this, I'm going to rename to webviews. The input here, everything else looks good. It's going to create an out file, um, and compiled and stick that there. And then everything else is just directly from oh, this one right here, svelte stuff. This should be webviews, all right? Rest of this looks good. Now, we're gonna also need to install all these packages. So, npm install rollup resolve common js and this one too. And this should be as a dev dependency. So I'm going to put a capital d flag here at the beginning. All right, we'll let that run. The only thing we need to grab is a ts config. So in the salt stuff folder on the Vasinder Github, we're going to go to ts config and I'm going to copy paste this. So you'll notice we actually are going to have two ts configs. We have one at the top level here. This is for our extension and everything that we write in source extension. And then we have a different ts config inside of web views. So inside web views here, I'm going to create a new file tsconfig.json. The reason for that is felt needs a basically typescript settings that we import from here than our extension does and so this allows us to use different ones. All right, so it's good. We may actually need to install some more stuff in our package.json. I feel like there's probably some stuff that is just in here so let's go to the package.json of the sender and I'm just going to search for any felt stuff. I got okay, yeah, so I did not install this one so we're gonna grab the ts config salt and again this is going to be as dev dependencies. I think I got all this and we need a sauce felt silt check and sell to pee process I don't think I got any of those spelt svelte check it's felt pre-processed preview process. All right and we'll see if anything crashes but I think that should be everything. I'm going to close some of these open tabs because I have a lot open and then I'm going to create a new folder here which I'm going to call components and this is where I'll basically stick the actual salt stuff. So here I'll say hello world dot svelt and here I'm just gonna have a div that says actually let's do an h1

Webviews tsconfig.json. Yeah, this looks right. Oh, that's right. So I need to exclude that file. So, okay, this is the error that we're getting. Notice how it says file helloworld.ts is not under the root directory. So, this is a TypeScript error that's complaining about. Um, and basically what it's saying is our ts config here on the outer level should ignore all of our Svelte TypeScript code. So, we just need to come into our ts config here and exclude it. And that's because we already have a different TypeScript config that we're using inside of webviews. All right, so let's try this again. All right, compilation. This looks like it's working now, and I'm just going to shut down and reopen this window. Actually, I'm not reopening. Is it not going to do anything because we actually now need to point it so you now you see how there's like a new folder called out and then compiled. You should see a hello world.js, and this is basically your compiled JavaScript code from the Svelte. So, now we're going to go into our panel, hello world panel, and instead of pointing at media main, we're going to point at out and then hello world, and now I'm going to press F5 and launch this. All right, so now let's run our hello world, and now this hello world should be coming from, from uh, Svelt. Um, actually, that's the other thing we need to do inside of, yeah, our panel at the bottom. I had like this h1 and this input, we can get rid of that stuff. We don't need anymore because we're now going to do that all through Svelt and if I look at this, okay, yeah, I'm just it's targeting the document body, so this is where Svelte's going to start doing its thing. Is on this body element here, just making sure is right. All right, let's refresh and see if that does its thing, and I'm not saying anything so I'm gonna do my webview developer tool console. Unauthorized. Oh, I totally forgot about this. Okay, episode by default it's going to restrict what stuff you can load inside of your web view just for security purposes and if we scroll up, I believe it's somewhere up here. Yeah, see how it says it's right here where it says create a webview panel, local resource routes and we can do media out compiled. Wait, I I should be allowing it, I think what I don't have is maybe oh, the content security policy. So, I don't think it's the content security policy that I need to update so if you're doing this on your own and you get an error, make sure that you come to this section here. I already have mine set up but in the webview create webview panel and local resource routes you have to allow each one. So, I have it allowed out compiled that's where mine is but if you put a different name or different path to your JavaScript code you're going to need out of here so just keep a note of that and then down here we need to update the content security policy to allow it and it's going to be a script source so we're going to add it right here. I actually don't know if script source is where I'm supposed to put it I actually don't remember where you're supposed to put it let's just go copy from here. All right, so source sidebar provider will work fine and if I come down at the bottom here. So all right, this is my content security policy right here the default is API I don't need that

Custom command to make our lives way easier. Basically, all it's going to do is close this panel for us and then reopen it, so we don't have to do that every single time we make a change. Just a quality of life improvement, you know. So, I'm going to go into the package.json and add a new command here, which I'm going to call 'Just Refresh Webview'. And I guess 'Refresh Web Views'. Now, we'll just call it 'Refresh'. And then here, call it 'Refresh'. And again, I'm not sure if I like mentioned this before, but the thing you put here should match here. The only difference is you put this colon command in front, so it loads. All right, so it's going to be 'Refresh', and then inside of our extension, copy this, paste it, and we're going to say 'Refresh'. And then we're going to say 'Hello, World Panel', and we're going to kill our panel and then we're going to recreate it. 'Creator Show' and pass in our extensionary. All right, so I have to reload this so the command loads, but now what I can do, so let's say I have this panel up right and I make a change, so I now make this 'Hello, World Three'. I can just now come here and I can run my command 'Refresh', and this is on VS to do. Refresh. And you notice how it reloads and now we have a three here, right? Very handy, very easy to work. Now we can go a step further because maybe I'd like it to also open up the dev tools right for me. I don't have to come in here and open web dev tools every single time. That's really annoying. So how can I make it do that? Well, if I open web dev tools, so this is actually a command that we can execute, and if I click that little cog at the end there, it'll actually take you to the keyboard shortcut, and more importantly, the name of it. If you right click on this, you can actually copy the command ID. All right, so just uh, to recap what I did, is this is the command I'm interested in, right, and I just typed 'Open Web Dev Tools' to get access to it, and I hit the cog, took me here and now I'm copying the command ID, and now I can tell VS Code to execute that command here. So I can say 'Hello, World Panel', dot, sorry, not that, VS Code. So whenever you want to interact with VS Code, usually you use this 'VS Code' thing up here that you import. So this code, it's going to be under 'Commands', dot, 'Execute Command', and then you can just paste in that string and it's going to execute this command. Now, if you hover over this, you'll see that it's thenable. That's the other thing I don't think I mentioned yet, both TypeScript. This is the return of this function. So let's just recap this real quick. Hover, so I'm hovering over this to actually see the tooltip, except it's not working. There we go. All right, so here you can see the start of the parentheses. That means this is the parameter one, this is the rest of the parameters, so you can see it takes a bunch of them if you want to. And then you see the colon, this is the return type. So that's how you break down the types for TypeScript there. All right, so this is going to open dev tools. Now, the only thing is, dev tools only works when this panel is open, and this 'Creator Show' thing is not like instant. And you'll see what I mean. So if I reload this, I actually don't think if I do my refresh, see how it doesn't actually show it. So what I did my code is I just did a set timeout, and so this only um, executes after it waits 500 milliseconds. So I'll come over here and refresh, and this pops up, and now you see dev tools now pops up. So just adding a little bit of a buffer, it works. Now, I don't want to come here and press the command every time I make a change because that's still annoying. So what I like to do as well is add a key bind to that. So again, I came here and I hit the cog from the command palette, and so now that I'm here, I can add a keybind. All I have to do is click here, and personally what I like to key bind this to is 'Alt' and then 'R', and you can see I already have an existing command. That's fine. Wait, come on, yeah, that's what I want. There we go, and this just makes my life real easy. 'Alt R' and we're good to go. So now the life cycle or how we're going to work here is I'm going to say 'Hello 4', come over here 'Alt R', right, add some more, save the file, 'Alt 4' changes and dev tools is up. So that's going to be our workflow from here. So get comfortable with that, get a good keybind, and then you're going to be able to iterate very quickly. Now, creating full screen panels like we did with this 'Hello 1 2 3' thing are great when you want to take over the entire screen, but again, the user can also split screen if they want to. But a lot of times, you just want to display a web view or just some custom content in the sidebar here

So we're going to head on back to the sender on GitHub and we're just going to copy a little bit of boilerplate again. So at the extensions level, we're going to start in the package.json and so we're going to be creating a new sidebar view and so we have to tell VS Code that we're adding this. So under contributes, we're going to add a view container and a views. So we're going to copy both of those. I'm going to go to the package.json and by the way, I didn't mention this. If you just hit control command p, this will bring up the palette and if you don't have a carrot, so when you have the carrot, you can do commands, but if you get rid of the carrot, these are all the files in your project. And so I just typed package.json and hit enter and it takes me to that file. So that's someone how I'm going to probably navigate a lot of times. And so give that a try, it's pretty handy if you don't use that already. All right, so I'm pasting that into my contributes here and so there's a few things we're going to swap out. We can give this a custom name, so I'm going to call this VS to do. The title of this is going to be VS to do icon. We're going to talk about it in a second but basically this can just be a custom SVG and it can be whatever you want but we're going to come back to that. The ID here, again I'm just going to pick something custom. So VS to do and the name VS to do and VS to do here as well. And then we just need to add an activation event. I believe, yep, on view this and this is just so it initializes the view and the name here should match what we put here. So copy, paste. All right, so now we need to decide what we want the icon on the side to be. So if you want to look kind of VS Code-like, you may want to go to codicons. All right, so let's click this one. So this has all the codicons for VS Code. So these are all icons that they kind of use. So I don't know if they have like a to do icon or maybe a list. Perfect, so they have a checklist so maybe I'll use this checklist one. So once I find the one that I want, I just go to their GitHub and I go to their source icons and I said I want a checklist. I click on it and I just grab the SVG here and I'm going to add this to the media folder and I'm going to call this checklist.svg and pop it in here. You can use any style SVG but this will just blend in with the icons well since these are all codicons as well. All right, so I'm going to go into my package.json, just call this checklist.svg and checklist.svg so in both of these places icon here and icon here. All right, so after we have that, we're going to go into our extension here, extension.ts and we are going to initialize that view. So we're going to grab that from oh we don't need codicons anymore. So I'm going to go to extension source extension and the sender and we're going to copy this bit right here. So lines 15 through 21 here and we're basically just creating a sidebar provider and then uh registering it here and I'm going to paste it and I'm going to get rid of this console.log. I don't know why I didn't kill that before. So we need to actually create our own sidebar provider here, we just need to pass in the ID. So VS to do and the string here should match what you set in your package.json for the ID. All right and let's add the sidebar provider now. All right, so I'm going to go to sidebar provider and copy the one I have from Vasinder and we're going to rip a few things out but this will give us a good base. There's a little bit of boilerplate for creating this kind of like the other panel. All right and we don't need anything but these two so get nuns and on the webview on receive message we don't need this all this stuff we can remove for now. I'm going to keep like an on info one if I have that yeah. I'm just going to keep the on info and the on air those are nice ones to have and we're going to talk more about receiving messages but basically all this does is it displays an information message or an error message if one comes from the web view and I'll show that a little bit later. Alright so here we have the same basically logic you'll notice how this looks very similar to the panel we're just creating. We're again loading right CSS and JavaScript as well and uh actually did I write custom sidebar CSS oh you know what that's actually coming from svelte because svelte can have CSS so I should show you guys that as well so we could have actually done this as well for the the side panel but we'll get into that

From default source all the way to this semicolon here, and I can get rid of the script tag. And now I'm happy with this. I think this looks good. Now, I think we're just going to reload and just make sure that we see our icon on the left side. It shouldn't actually run yet because we don't have the sidebar JS and the sidebar CSS. But I'm just going to reload the entire extension. So again, whenever I make a change to the view container of a center sidebar does not exist, all views registered to it will be added to explore. All right, I kept something with the word the sender in it. Oh, it says it right here. So this should be VS To Do Sidebar View is what I want this to be called. And this is just in package.json that I'm making this change. Oh, and I kept the sender here. So this is my Hello World panel. I'll just change it to Hello World. I don't think that really matters. Does not register all of these Russian verbal explorer. I'm just going to reload it. So actually, I don't think it was a problem with that. What is okay, it works. I actually have no idea why I was complaining about my previous name. I feel like that should have worked all right, but you can see it also has VS To Do like a little tool tip. And I can see my thing. And if I click on it, it looks like it crashes, which makes sense because sidebar provider is not defined. Oh, we didn't import it. So back in mind, I'm going to close this. In my extension, I actually didn't import this. It's awkward. No wonder it's crashing. All right. So command period, by the way, for to auto import that all right. So now we can actually add signbar.js and sidebar.css and we can start rendering some stuff there. So all we're going to do is same thing. I'm in web views pages. I'm going to create a sidebar dot TS. And by the way, uh, capitalization matters here. I'm going to just match it. So I'm doing lowercase. I know we did uppercase here, but it's whatever. I'm going to copy the Hello World.TS. I'm going to paste it in, and I'm going to call this sidebar.spelt and create a sidebar dot svelt. And we're just going to say hello. I'm going to save that and please recompile dude. Oh, I think I might have to just control C and run MP and run watch again to make sure it re-spits it out. Yes. So again, look in your out compiled. You should have a sidebar.js file there now, and there's not a CSS file there right now, but if you add a style tag here and we'll just make the div color pink. How about that? All right, CSS go. Did I break it? Oh, there's not a plug-in that we need. Uh, directly after number identify directly. Sidebar.css. Oh, the web view broke. I think I don't know what happened. I'm going to refresh this. Do I need to have a script tag up here? And it doesn't have it. I don't think that's the problem. I usually have a script tag up here and this is where we're going to do some spelt stuff as well. I'm just going to control C and rebuild it. I'm assuming we're missing a plugin that we need. Okay, so I figured out I got it all working now and sidebar.css is spitting out just fine. So I was actually doing everything correctly. Uh, we just have to downgrade our roll-up plug-in spelt and also I'm just matching my rolled version as well. So these are the two versions that I'm using and they confirm work. So if you don't get an error, maybe just use the latest version, but if you are getting an error, try downgrading. And these are the two versions that worked for me and it compiles just fine. And now in my sidebar that's felt, I changed it to red. Just to make sure that wasn't the problem, but yeah, it spits out a CSS file whenever we add styles here. So awesome. So now if I go back to my extension and I just reload it, it should now actually load hello and it should be red. Um, if you see that clock there, that just means it's loading the extension. Takes a second for the web view to load. Nice. So now I see it says hello and again, you may want to set yourself up with a hotkey. Right. If I make a change here, I can close it and reopen it and then it reloads it here. That's the quickest way if you just want to manually do it. But what I like to do is go and update my little command here. So you can either keep this if you're working on the panel and the side panel, you can do both. I'm gonna comment these out because I'm no longer working on the hello world panel. So I'm just gonna remove that. So on my refresh command, what I wanted to do is basically close the sidebar and reopen the sidebar. So if I look at this, there's literally a command called close sidebar. So I can click on the cog and I can right click and I can copy the command ID and I can say await VS Code commands execute command and I can tell it to close the sidebar. And I'm just going to make this function asynchronous and then I can tell it to open the sidebar and in this case, VS To Do

Yep, see how there's a view. So here, I put VS2 because that's why I named it. Whatever you named your extension, you can search it here. See how there's a view show via to-do, that's what I want. So I'm gonna hit the cog, copy that, and this is what's gonna open the sidebar. And we're gonna paste that in, so close it and then reopen it. So I'm just to reload this and we'll let that load. And then when I push my hotkey, again, did I set it to alt 4? Yeah, I did. Okay, cool. So it closes, reopens, and opens step tools for me. So let's make this blue for example. And the watch command's going to recompile the CSS for me. Alt r, and it's back, and it's there. So perfect. We're basically all ready to just start developing on our sidebar with the webview here. So I want to start out by starting with a basic to-do list example and just get you familiar with svelt. So there's basically three parts to this HTML stuff that we put down here, and then we're going to stick any kind of CSS styling between the style tags and any kind of like Javascript logic we'll type script, we're going to stick in the script tag up here. So we're going to start by just creating an input field where we can add to-do's and I'm just going to create a variable up here to store the to-do's, which is just going to be an array. And I'm going to say, let. So one thing I've noticed myself doing is just in uh, svelte, I tend to use let a lot. In other languages or frameworks I can react, I'll use cons kind of everywhere, but with svelte, you can just kind of mutate things. Like just real quick, if I create a counter, zero, and let's say I want to display that counter. Same thing, you can just do curly braces and then display the count. And I want a button to increment. On click, you'll notice this is the syntax to do on click. So it's on colon and then click. I can just say count plus plus, and what this is going to do is it's actually going to one increment the count, but two cause the re-render and display this. I don't know if people talk about re-render since felt but I think of it as a re-render. So now if I come back over here alt-r, wait bro where are you at? Did I stop my oh I stopped the compiler. Yarn, you know I said I was using it's so hard for me not to use yarn. I don't know why I promise to use mpm here, I just kind of want to try it out, you know. All right, so I made the color blue, I'm gonna get rid of this for now. All right, so I'm gonna increment, and you notice it just increases the number. Awesome. So that's really handy so because of that I tend to use let because I tend to mutate things. All right, you can keep that example if you want, I'm going to clean it out though. I'm also going to have some text. This is going to be the text for the input field. So this is another really handy thing you can do in svelt, is let's say I want the text value to equal it's in the input input field here I can just bind the value. So bind value I put the text in here and so if I have text colon and I display the text, whatever I type in this box is going to display right. So hello. And by the way, I'm going to turn off my um open devtools for a second because I don't really need dev tools right now and it freaking unfocuses the window every single time it's kind of annoying me um and I'm just gonna have to hard reload for that to uh take effect. And by the way, I did that kind of quickly, I just went to extension and uh commented out the set timeout part and the refresh command. All right, so yeah, so every time I type you'll notice that these just match and that's because whatever I type in this input field now is binded to that variable here and then all I want to do like if I want to have a button here to reset the text, I'm just going to on click and I set the text to an empty string. Okay, so I'm typing, I press reset and then you'll notice I changed that variable and now the input field is cleared so very nice

"Is a string and completed which is a boolean. All right, so I'm just stringifying the to-do's, and this just makes it look pretty. Down here, we can see just a raw dump of the to-do's while we're doing this, and then we'll build out the UI in a second.

All right, so we can say on submit, and uh, we can get the event handler, and I believe I can just call like prevent default here. Um, but there's also like this pipe syntax we can use, and we can say prevent um, default or something here. I'm not getting any auto-completion, so I actually don't know what the syntax for it is. I don't know if you just uh, put this, let's see. Prevent default Svelte event modifiers, yep, this is the exact thing I was going to show you. Show me. You can just put it here. Which one is it, stop propagation prevent default? Okay, these are the list of all the modifiers that we can add, so prevent defaults right. Um, basically I believe these two are just equivalent, so I could call e.preventDefault, or I could just use this pipe operator in Svelte.

All right, so this is when our form is submitted, the person just is hitting enter in the input, and what I'm going to do is I'm first going to add an item to our to-do's. Now normally I would just push onto the array, but in Svelte, it doesn't know that we mutated the to-do's array if we just push. So what I like to do instead is just reassign every time we reassign like this, Svelte knows that we made an update. So I'm going to say dot to-do's, by the way, this is super annoying. You see what I did there, it said dot dot, and then it takes the auto-completion. Yeah, you're just gonna have to live with that, super annoying, or maybe someone knows a fix. Let me know in the YouTube comments if you do, because uh, that's absolutely killing me.

All right, by the way, to get around that, I hit escape. Oh my gosh, I messed it up, so dot escape dot, and because of environment really messes things up. All right, so I'm going to keep all the to-do's, and actually why don't we put our new to-do at the beginning here? So it's going to be a new object where the text is equal to whatever text is currently in the input field, and then I'm going to say completed is false, and then I want to clear the input field. So I'm going to say text is an empty string after this, right? So, come over here, I'm gonna say one, two, three, right, so I just typed in input field and hit enter, and you'll notice we just get a nice raw dump of the data here. So you can see we are adding items to list and it looks nice. So that's good. So the next thing is just to render those as literal items. So, uh, I guess make a ul tag and we'll put some lis. So how do we loop and display information? We don't need hello world, so getting rid of that.

So in Svelte, they have these kind of hashtag things, so we're gonna do a hashtag each, and I believe, so by the way, how I did that is it was an auto-completion thing, so if you go down to ha, if you do hashtag with brackets around and then, I push ctrl space just to trigger this, and then the one with each is the one you want to press.

All right, so we're going to say each to-do's as to-do, so this is the name of the array that you want to iterate through, and then this is like a for each loop basically, and then here's the name of the variable that you want to use in the for each loop. So I'm gonna say li here, um, and we're gonna display it to-do. Now you can also put a key, man I think you just put key like in parentheses like that, and maybe I'll just set the key to to-do.text, and that's going to be the text. Maybe we should be using unique ids, I'm not going to worry about unique ids for this for now, I'm just going to set the text so you type some unique text please.

All right, so the li we have our list item there, so one, two, three, oh awkward, so I didn't actually say to-do dot text, I just said to-do, and I believe you can also destructure there if you want to, I'm not gonna try it though, I'm just gonna say to-do.txt.

All right, nice. All right, so now we have some items, great, so next I want to be able to like click on these items and cross them out, so I'm gonna add it on and click, and how are we going to keep track of what's, I guess we'll do it. So actually, um, I think I can just do this, I think I can just say to-do dot completed is equal to not to-do dot completed. I don't know if this actually works, but we're about to find out. You notice how I didn't have to like look up the index and the array of the to-do's, I can just literally mutate this to-do value. I should probably wait and see if this works before I tell you how cool this is. I really like doing things like this, I think I did this a while ago and it worked, so we're going to try it, but basically this is just an element in the array and I want to change it

All right, so that's on the on-click. The only thing is nothing changes when we flip this, so let's add a class. So this is going to be like cross, we'll call it complete. So in CSS, you got to put a dot here if you want to target a class. And uh, it's called line style, I believe. Lion style, line style that exists, right? I thought I saw something. Style, list style, text style. What is it called? Text decoration style probably. I forget, line through. CSS text decoration, that's what it's called. All right, so it's tech decoration and we're going to say line through. All right, so now we just need to add the CSS class whenever completed is true. So we could do like some kind of conditional, but there's also a special felt syntax we can use, so just to show you the basic example, I could say todo dot completed and then we could say complete or we could have an empty string. And by the way, in svelte, you just say class, no class name. Or what I could do is I could put a colon here and put the name of my CSS class, which is just complete in this case, right? And then I can put the variable here, so when this is true, this class will be applied and when it's false, it will not be there. So this is just like a short syntax for it. All right, so if I click this, yep, now we got a line through it. Now you, we can appreciate how nice that syntax is. I just mutated the todo that I wanted to change. There you are, you have items that you can cross out. All right, I think that is a pretty good intro and just felt over some of the basics. You got a little gist of how it works. We're now going to layer some more complexity on top of this, so a common thing that you may want to do is have your web view, which is written in svelte, communicate with your extension, which can access all the VS Code APIs. So for example, I might want to show like a little pop-up or do any interaction with the editor that the user has up. So how can we do that? Well, we can actually send messages through svelt to the extension and that's what we're going to set up now. So if you go over to the example that they have for the webview sample that we had at the very beginning, we're going to copy a little bit of a code from that and really it's not that much if you just want to type it out. But there's this special function we can call called acquire VS Code API. This is something that VS Code gives us access to in web views and this gives us access to a VS Code object which can give us different basically APIs that we can use and the one we're going to be using is the post message method which just lets us send a message back to the extension. All right, so what I'm going to do is I'm actually going to go to our sidebar provider and at the very bottom here, I'm just going to add a new script tag. Do people put script tags in heads? I actually don't even remember. I'm going to just stick mine here. I haven't like manually written the script tag in forever. All right, so basically we're just sticking this this line of code in a script tag. A lot of nuns to it, nuns and I don't think we need anything else. Now you can call it just VS Code if you want to but I like to preface prefix it with TSPS Code just so I know that it's different because uh, this VS Code object does not have everything that this VS Code object has right that we're using inside our extension. They're two different things, so I like to just prefix it with the TS. All right, so now I can actually access this TS VS Code object in my cell code. So in my sidebar here, maybe at the bottom I want to add a button, so I could come to their example and I could copy their little post message right, and I was about to wait it, I don't need to. I'm just going to put TS in front. Um, so the command this is so this is what you actually pass in this post message is whatever you want, this just happens to be like a standard practice is to put a command like what you're doing. So the ones that I used if you go to the sidebar provider, two ones that I use is on info and on air, so on info what I'll do is I'll take the value that's passed in assuming they pass in a value and I will show an informational message or if it's an error I'll show an error message right. Okay, so on here I would say on info and then value this would be the message for my think so info message and maybe I'm going to copy this button and have an error message so you can see what both look like. Um click me for error

Going to create a new file here called globals.d.t.s. So the name of this file doesn't really matter. I just call it globals and then the dot dot ts is an extension. I think the d stands for like declarations or something and so in files like this, I will say declare module or actually it's I think it's like declare global or something like that. And maybe I actually extend it. I forget the syntax let me see what I used in the sender and so this is going to be in my extensions. Svelte stuff shared globals. All right. So no, I just declared it global. So I believe global is a special keyword. I didn't know if I had to like extend it or something. You can see here I actually have my const uh ts vs code and actually what I'm going to do is actually make this an object because I can actually declare this a better type than any and what did I call this okay it's called post message. So inside of here I can say post message and this is going to be a function that is void and it's going to have a command which is a string and a value which is anything. So now that we've created this global type here, TypeScript should now be happy with us. It's not happy with us. I'm just going to hit command shift p and restart the TypeScript. Actually, I guess it would be restarting the Salt language server so let me try that and see if it and now likes it okay. Doesn't. So this happened to me before as well and surprisingly enough I believe it was this import that made TypeScript recognize things. So I'm just going to stick that up. You'll notice we're not actually using this anywhere but as soon as I put that import in, it just works here. Uh, by the way it's going to complain about it's not defined. This is just a warning and I just ignore this. There might be a way to disable this globally but I don't know what it is and I didn't bother to look it up so I'm just going to keep it like that. But yeah, notice as this import we're not using. I'm not sure exactly why it works. I assume I guess when we import maybe it knows that this file exists and didn't know this file exists before and maybe we could like include it in our ts config and it would work but whatever the import works so we'll just keep it all right. So let's test this out now. Alright. So if I say click me and click for error nothing's happening. Oh, I'll tell you why nothing well actually no oh yes I'll tell you why nothing's happening um. So remember so by the way I do this to myself all the time. So remember how we just edited sidebar provider.ts right we added this so that means we have to do a full reload not a webview reload I always forget that. Basically if your code's not working you should probably just do full reload because you probably just forgot to do that. All right. So we press click me all right now we actually have problems. Let's open up our webview. Am I just being a noob. So let's go to my sidebar provider let's see if we're getting a message. Oh wait okay so I call it data.type so that's what's going wrong probably so commands here is from theirs I'm going to rename this to type. All right. So my I just need to make sure that I was using right convention so I used a slightly different one and by the way a command click can actually take you where the definition of this is you can also right click and go to definition so that's why I just click to go here and I'm just going to rename the type or re-declare it or just change it because we didn't we're not using command all right so I'm going to reload this again and the this is can just do a webview reload I believe yep. All right. So we got an info message here can click for an error and there you go right. So we can pass whatever information that we need to to the this part but this on did receive message is the the part that we can actually listen for these so here we can do any vs code commands that we need to do right there's a bunch of them and so this is how you would interact from the webview part so if the webview needs to tell the extension to do something that was how you do it

"And I'm going to call this 'Add to Do' and 'Add to Do from Selection' is actually how I'm going to do it. So it's going to get the to-do from whatever I have highlighted here. And then we just need to come up to our activation events and add this command 'Add to Do'. And then in our extension, we need to initialize this new command, so it's going to be 'Add to Do'. And just to verify we have this all hooked up, I'm just going to console.log 'Hello'. So I hit Ctrl Tilde, and I'm going to go to the debug console, and I should see 'Hello' here. So I'm going to reload, and this is a full reload because we changed the extension. And now I'm going to say 'Add to Do from Selection', and it just says 'Hello' down here. All right, so that all wired up correctly. Um, so the next thing is I want to get the selection of here. So if I type 'vscode.window.activeTextEditor', this is an item which can possibly be undefined. If I hover over this, I can see that. So you usually want to do a check, you know? So I might destructure this and not color theme active text editor. So if they don't have an active text editor, maybe we just tell them a message and we return. All right, so if I come over here and I reload, and I close my index file here and I try running this 'Add to Do from Selection', it's going to say 'No active text editor', right? But if I close that and open this, this is considered an active text editor, and so it is fine. Now, this has a ton of useful information on it. If you click in, you can see kind of information about the document including the current selection. If I hover over this, you'll notice this is really just an array or index, so it tells you like from 0 to 7 or whatever. So what we're going to do is we're going to say 'activeTextEditor.document' and then here we can pass in a range or a selection, and if you don't, it just can give you the entire text of the document, but I just want the selection. And can selection be null? Nope, looks like it's always going to have a value. Um, and I was thinking about making a check here if the text is empty, but I'm not even going to worry about that. What I'll do is I'll just log the text to the window. So I'm going to say 'text: [display the text]'. Right, so I'm going to reload and we're going to hover and press it and we'll attack it. Actually didn't get my text. I wonder if it like got rid of my selection as I was doing it. All right, so let me select again. Command Shift P 'Add to Do from Selection'. Okay, good. I just kind of lost my selection. I think it's because I was using vim and it messed up. But you can see here's the text I got from the selection. So coolio. The next step would be to actually send this text to our web view. Right, so now that we have something that we want to send to our webview, let's send it. So our sidebar provider up here, sidebar provider, and it's going to be 'view.webview.postMessage'. All right, so this is a function that we can call to send a message. And I actually can't remember if this has to be a string or not. This must be a string or other JSON or other JSON serializable object. All right, let's send an object. It's going to serialize it for us, I think. All right, so the type of this is going to be a new to-do and the value is going to be the text. So now the only thing left to do is on the side in our web view, we need to listen for the messages that this is going to send. So that's going to be in our 'sidebar.svelte'. We don't need these buttons here, but I'm going to leave them for now. And so in our script tag up here, I'm going to call the on mount function. So this is a special function that's Svelte gives us. You'll notice it auto-imported from Svelte as I was typing that and I hit enter. On mount there and so this function gets called when the component first gets mounted. So this is a good place to put listeners and that sort of thing. So if I go back to the webview example, I can see that there's a 'window.addEventListener' at the bottom. So I'm going to copy this bit and again this is from the VS Code extension samples webview sample, so you're probably going to keep this up. We're going to have to copy a few things from here. Well actually not where this is all we need for this but maybe in the future. All right, so 'event.data' we have a 'message.command' so in this case ours is going to be the type and it's going to be 'Add to Do' and then we're just going to say 'todos' is equal to 'I'm going to add this to do' so 'text' is equal to 'message.value' right because that's what I called it here 'value' yep. And 'completed' is going to be 'false' and I'm going to say '.todos' and I'm just gonna console.log the message to make sure it's the shape that I think it is and I put curly braces around this just so I could see that messages in the log and I think this looks pretty good. Let's try it out

Because I can't remember if I change the extension, I'm going to open my sidebar. I'm going to select some text and I'm going to add to do from selection. Um, it did not work. So why don't I toggle developer tools, see the object? All right, so message. It says new to do value. Wait, this actually looks right. It got the data. It just didn't add it to do. So I said to do's is equal to to do message.value. Oh, you know what? I said add to do and I said new to do here. I wreck myself every time with this. All right, I'm gonna get rid of that. I think we're good with that. And I think this will work now. Highlight and add to do from selection. And nice, I can see my to do item here. I can cross it off. It's just like a regular to-do item now. But there you go, that is how you can actually send info from here or really just your extension to the web view, and you can send stuff back and forth if you need to send a data. There's one last thing I wanted to do here though. Is, uh, it's kind of annoying to like, you know, highlight and then go and run a command. Right? So it would be nice. There's just a button down here. And well, we can add a button down there. And the way we do this is in our extension here. Um, I guess we'll just add at the top. I'm gonna say VS code. Dot, ooh, I think it's called window. Oh, yeah it is. It's create status bar item, that's what it is. And there's like a status bar alignment. We're going to say on the right side. So here we can say whether we want our button to be on the left or the right side. I'm going to put mine on the right side. And here we can set the text for the item. So here I'm going to say, uh, add to do. You can also add like a little icons. Let me show you what I'm using in the sender. So I think I call it like status if I go to the file snippet status. All right, so you notice how you, I did a dollar sign and then I put parentheses and then a name, stick that here. It'll actually add an icon if you want like a little icon in your bottom bar. And how I knew what text to put here is this is just from CodeCons. So the VS code CodeCons. And if you just go to their page, you can pick whichever name you want. So let's do a beaker because why not? Um, and then what is the other item? I think you just have to say whether your snippet is, uh, shown as well. I have to do dot show and the command as well. So this is, uh, VS to do dot add to do. Did I prefix it with anything? Nope, it's just like that. Um, so what's going to happen is when I press the button down there, it's going to execute this command. And again, you can choose whatever command you want to. I'm just doing my add to do here. All right, so let's reload this and see if we see a new item. We'll give it a second. It's going to load the extension. And you can see my little beaker and it says add to do in the bottom right corner here. All right, so now I can select an item and I can just press this button, and that's pretty nice, right? It executed the command. And again, I could wire that up to our hello world panel. Like I could click this and it opens a panel. Can do whatever we want to do. But there you go, that's how you can run commands from a button and send messages. Now everything we've done so far has been local to VS code. So if I were to install this extension right now, all the data would live basically on that person's computer. But sometimes you want to interact with an API, store stuff in a database, and be able to share with other users. So that's what I'm going to show you next, and we're going to do a little bit of back-end development, set up a little API that we can interact with with our VS code extension, and also show you how to do authentication. Let's say GitHub. So what I'm going to do is I'm going to come back to our project over here, and I'm going to create a new folder where I'm going to put the code for this. So I'm going to make a new directory here, which I'm going to call VS to do API. Then what I'm going to do is instead of opening this up in a new VS code window, I'm going to go file, add folder to the workspace, and I'm going to add VS to do API. And the reason for that is I now just have these two projects open at once, it just makes it really easy for me to switch back and forth. So I'm going to close this and we're going to focus on setting up the API now. All right, so I'm a CD into the VS to do API, and the first thing that I'm going to do while I'm in here is just run npm init with the dash y flag to say yes to everything, and then let's install some things. So first thing we're going to install is express. We're using express server and you know already we're going to be using TypeScript, so let's go ahead and install some dev dependencies. TypeScript, we're also going to install the types for node that's at types node

Are coding and what else do I want. Hyperscript. Oh, yeah. So I need a TS config. So for TypeScript, there's a configuration file. To get that, I'm going to use a utility that I made called TS config dot JSON. So all you need to do is run MPX in front of that, and it'll give you this prompt. I'm going to press node, and it'll stick a TS configure. And in package.json, I'm going to add two commands: watch. Oh, you know we didn't install the types for Express 2. So, express npm i d at type slash express. So if you've never worked with TypeScript before, sometimes libraries are written in JavaScript, and we want to use those libraries. So, for example, Express is written in JavaScript, but we want TypeScript types. And so, to install those so we know like if something is string or is it an integer, we can install a separate package here that gives us that info. So that's why we're doing this. All right. So, oh, you know what? I can't actually. It's going to tell me that. So if I save this here, it's going to tell me this, you know. So I'm going to close out. Don't save. The reason why I got that is because I saved. I didn't save the file, and I made changes to it, and I did an npm install and it added this. All right. So the watch command is going to just run the TypeScript compiler with the watch flag. And then the dev command is just going to run node daemon on dist slash index.js. So I'm going to create a new file source index.ts, and we're not going to worry about eslint for this. So, import express from express, and we're going to say app is equal to express, and we're going to be doing some async stuff, so we might as well just start doing this right away. And we'll make this asynchronous. So this might look a little funny, but what I did here is I made a anonymous function. That's what this is here, and I made that anonymous function call itself, and you'll notice the anonymous function here is just uh written in parentheses. Now the reason I did that is because I can use the async keyword and I can do a weight in here, and you may want to just rewrite this sometimes I do this if I'm looking to be really, you know, clear. All right. So you can use this if you just want to be super clear. You made a main function and then you have stuff inside of it. You can use the other one if you just want to look cool. All right. So I did app.listen here, and I'm going to put this on port 3002. I think because I think I have something listing on 2001. All right. So I'm going to just say console.log listening on 3002. And I'm going to say app.git and I'm just going to do slash, and this is just going to be a hello world example to get working. And we're going to say res.send hello. So, um, if you've never used express before, it's just a way to create a server. So we just set up a little API or a server here that starts on port 3002. And if you go to the URL locos 3002 slash and then nothing else, it's going to send back some text. In this case, just a string hello. All right. So we are going to say yarn watch to compile this and this should create a dist folder. Let's go ahead and also create a dot get ignore and say dist uh so when we compile the TypeScript to JavaScript, you don't actually need to put that into source control. All right. So rack is declared but its value is never read. All right. This thing right here. So we're not using rec so you can just put an underscore or underscore rec and then it'll be happy and vs2 api. So I just open a new uh window that way I can run yarn dev as well. So I have that and I don't think we need this anymore we're gonna go to locos 3002 slash and should say hello in your browser. That means server started up it worked you're able to see it and uh the initial setup is good okay so I renamed my folders a little bit so if my sidebar looks a little bit different that's why I just have api and extension reason I'm doing that is I wanted to make them under like the same folder that way I could have a git repository that encompasses both but that's just a heads up you don't have to follow this you can just keep what you have. I just want to let you know if it looks a little bit different on the side so the next thing I want to set up is to talk to a database we're going to be connecting to PostgreSQL because that's my favorite database and it's a great database to use so if you have not already go ahead and install PostgreSQL on your computer go to google figure it out and also create a database so I'm going to create mine right here

We have to install the pg package and reflect metadata. Reflect metadata is something that Typeform needs because it uses decorators. And if I go into my ts config, let me just make sure, I think I have decorators on. Yeah, so you need to make sure you have emit decorator metadata to true, experimental decorator to true as well in your ts config. And up here, I'm going to import from Typeform and also, you may need to make sure to import from reflect metadata at the top.

All right, so I'm going to say create connection. Now, you're going to see why we put this in an async function because I want to await the create connection. All right, so the type of this I'm using is Postgres SQL and also feel free to like swap this out with a different database. We're not really going to be doing a lot of database things in this, but I wanted to make this real so we are actually going to connect to one. So we have that a few settings I'm going to set. Logging to true and what I'm actually going to do is create a constants folder and I like to just create a variable called prod and this will tell me if um we're currently in production or not. So to tell, I'm going to look at an environment variable called node inf. If that is set to production, I know we're in production. If you've never seen this before, this is kind of a standard convention and node.js to pass in an environment variable called nodem to tell you if you are running in production so you can do things like this.

And so here, I'm going to say if we're not in production, I want to log and if we're non-production, I also want to synchronize. Um, the reason I'm turning off logging in prod is because as you're gonna see, it actually will spit out logs for every single SQL command and it can be a little much sometimes. Um, so depending on what you're set up, you may want to keep that on prod but I'd like to turn it off personally. Um, in synchronize, this is going to make sure that our database has all the tables and it's going to actually create it based on what our models look like and it'll make more sense in a second if you've never done this before.

Um, specify database name vs to do and then you need to create a user if you haven't. My username is just Postgres and I actually don't even need to set it. I believe my password is also Postgres. Um, I actually don't know if this works or not, I don't even have to set a username and password it just works but you may need to add those two keys if you create a user and you set a username password you can pass it in there. All right, I'm going to specify entities and for this, I'm going to just pass in a door name and we're going to create a folder for this called entities and I'm going to create a new one here user.ts. So each entity basically corresponds to a table in our database and actually, I was going to set this up so it gets the path but you know why not we'll do we'll do it, reason why it's sometimes it's a little sketchy because sometimes path is a little jank on everyone's computer.

All right, so I'm going to import join from a path. Dur name is a special variable that will get us the absolute path to where we are where we run this basically so it's going to take us all the way to index.tsc is how I think about it but if it's running in a dist folder it'll take us all the way to here. All right, so this is like a good one to use and then we're going to join this and we're going to tell it. Dot slash entities and then we're going to say star. Dot star and this will get all javascript and typescript files that way. I probably could just do this and I could also just do this because we're compiling but I like to do this because why not all right and join just takes these two paths and mashes it together and gets it to work on like windows and all the things all right so that's gonna create a connection let's go ahead and set up our first table. So I'm gonna say at entity and I like to extend a base entity this just allows us to do some uh user.find and I can just run these commands and create it's very handy. Let's make a primary column primary generated it's just going to be an id it's going to be a number and export this and for now let's just add just one column it's going to be a text column and it's going to be their name which is going to be a string

Just to verify everything's working and it automatically restarted for me. I can see how it inserted a user in and it gave me a user back, and I could see the object, right? And gave an id of one and his name is Bob. All right, so our database is set up. We're able to connect to it from Node.js using TypeORM. And now we can do things like this, so we can set up the rest of our API now.

Next, we're going to be adding the logic so users can log in with GitHub using OAuth. And to help us out with this, we're going to be using a library called Passport, and specifically this Passport GitHub package here, which also uses Passport. So I'm going to go ahead and install this library. I'm going to control C out of the dev for just a second, and we'll come back to it, and then we also need to install Passport itself. So do NPMI Passport GitHub and Passport, and then we're just going to copy their example. This just makes our life really easy to set up, so copy this bit, and if you just Google Passport GitHub and go to the readme, that's what I'm on there, and I like to switch instead of using var switch it to import syntax. And you can see it says dot strategy there, so this should really be strategy, but if I hover over this it says cannot find decoration file. So this is one of the cases where this library was written in JavaScript, and since we're using TypeScript we don't know what the TypeScript types are. So what we can do is this command right here, copy it. Now this doesn't always work, but in this particular case, I know that Passport has types, and also while we're at it, I think we can install Passport types too, so NPMI --save-dev. By the way, big d is equal to this flag, those are both equal. Um, yeah, so we have those two types. So now it's barking at us because this GitHub strategy is not something that we can actually import here, it's actually called strategy, but I can use the as keyword and then a new name here, so this is me importing strategy, but I renamed it to get up strategy.

All right, Passport. So we actually, I don't know if they're gonna have the Passport logic here, no they're not, so we're just gonna have to go to Passport, Passport GitHub, and this is the one, and this is what we need to set up. So we're using Express, it's gonna add a middleware, and we're gonna say Passport initialize. We're not using sessions, so we don't need to do that part, just this one. All right, so Express down here. Oh, we need to do, should we do CORS right now? No, I'm going to wait and show you how to handle CORS errors in a second is what I'll do. So import Passport from Passport, um, I actually forget if we have to like create a Passport instance or if it's just the global, it looks like it's just global. Passport initialize, I also had to deal with serializing the user, I feel like I needed to add that last time I did this, so I'm going to copy this Passport.serialize user, um, at least let me just go to my Vicinder and make sure if I did that or not. I'm just going to search for serialize, yep, add my serialized user, Passport serialize user, and we'll copy this bit. It's the same thing I had before, I just wanted to verify that it was. So I think I did user.id was in the original example. I'm gonna have it be user.access token is how you use a string, and serialize just means we're gonna pass an object for the user, and we need to turn to a string, and so to turn into a string, we pass it. Uh, we're gonna pass in an access token, so that's gonna be what we turn to a string, and this is just the callback, looks like I made the type any. What's the type if I don't set it to any? Oh, it's unknown, okay, so yeah, we need to do that. I'm just going to set it to any, that's fine. Uh, and actually, why don't we set this above? I'm not sure if I need to do that above initialize, I probably do, and we're gonna copy this part here and stick it down here. All right, so we need to get a GitHub client ID and a GitHub client secret, so to get those things, if you go to GitHub and you click on your profile and then go to settings and all the way at the bottom there's going to be developer settings, OAuth apps, and here you can add a new OAuth app, so you can see I have something here, create a new one, and I'm going to call this VS ToDo, and for the homepage, this really doesn't matter, this is only for the purposes of users, what you want to show them. I'm going to set mine to just localhost 3002 for now, um, application description again doesn't matter at this point, and uh, callback URI, I'm going to copy this part, and there should be low cost

Okay, but this is right and this path is important. We're going to be using that path in a second. So, register. All right, this is my client and now I'm gonna generate a new client secret. Hopefully, this doesn't show on screen. Okay, so I just copied my secret to my clipboard, and now what I'm going to do is I'm going to create a .m file. This is basically a standard, a good practice to store secrets. So, I'm also adding the git ignore m.m. So, this you do not want to show on GitHub, and what I'm going to put here is this GitHub client secret. And then I'm going to paste my value. I'm not going to paste in front of you because then you would see the value, but something like that GitHub client id. All right, so it's going to look like this. I'm going to go paste in the real values. So, yours should look like this, and you paste in the real values here, and what I like to do is create an example of this. Example so, what I'll do is I'll actually come over here and I will just paste in the dot example, all the environment variables that we're using. In this case, we're just using these two, and this is something that I will push to get, and that the reason I'm doing this is anyone who uses the project knows all the environment variables that need to be added. Now we need to do one last thing to be able to load in those environment variables and access them here. Um, so to do that, I like to use a library called dot m safe. dot m safe just is gonna read the example file and make sure that they're all defined, and then I'm just going to require dot m safe and dot config, and I like to add this at the top and this is where the environment variables are going to be loaded, and I also like to actually use a little. So right now, if I do process.m dot, I don't get auto completion. It doesn't tell me what environment variables I have access to. So, what I can actually do is run this command called mpx. Gen inf types and uh, these are the flags. I actually don't know if I think my things will just go by default. I forgot honestly how I coded this. Let's see if this works. You might just be able to say mpx gen and types.m. Yeah, it does that by default. Nice. Actually, I don't like it because I want it to be inside my source folder, so actually never mind. Yeah, I'm gonna do like this so I'm gonna create a types folder inside my source. So, this is a little cli tool that I made that basically it's gonna read your environment file and then generate typescript types for it, and so yeah use these flags right here. These are the good ones and we'll rerun it. Um, refresh. Oh, yes, here we go. So, I'm gonna delete this m.t.s so when that's done running, it should have added something that looks like this, and now the reason why we do that we get a client id right process m dot client secret. Now we get auto completion and it knows it's defined it's a string. All right, so this is going to be localhost and uh, this callback URL should match whatever we gave GitHub. By the way, and there's one last part to passport. We did this and this is the thing, so we're gonna have a callback and also what URL they go to. So, we'll paste those in so now when I go to slash auth GitHub that is how I initiate the user to log in with GitHub, and then this part here, this is what's going to be called after the user's successfully you know logged in and it's called back. So, this part needs to match this up here and it does. I'm not going to worry about a failure redirect because we don't really have a really a website. All I'm going to say here is I'm going to rez that I'm going to send and I'm going to say here like you logged in correctly. Um, oops and I'm gonna underscore that. By the way, underscore is just kind of a convention the typescript knows that this is not used. So now if we come up here to our function we need to fill this part out as well. So what we're going to be doing is GitHub is going to give us a lot of information and you're going to see that information in our log, so I'm just going to log the profile there and here we can say null we did not get an error and this callback is what we we call whenever we're done with whatever we want to do in this function. We're actually going to create a user but not yet I just want to show you what this logs first. Um, so we're going to call the callback and then the second part is any info that we want to pass to our callback here so what I actually like to pass in is an access token and a refresh token we're actually not going to use the access in the refresh tokens there so you can ignore those and I'll just make them underscores we're going to create our own access token and our own refresh token now if you wanted to make commands on a behalf of the user using the access token and the refresh token you could but personally for this project we're not we're just using GitHub to actually verify their user and they can log in

Verify their user and they can log in. All right, so we're gonna give this a save. So now in my browser when I go here, it's gonna ask me to log in with GitHub. All right, so actually let me make sure I have the server started, so npm run dev. All right, it's got a little close 3002 slash auth GitHub, and you'll notice like it redirected me if you look at the URL. I'm now logging in with OAuth at GitHub.com. So this is good so far, and then I can authorize it with my GitHub account. Now I'm already logged in with GitHub so didn't ask me, but if you're not logged in, you'll have to log in. All right, so I'm gonna authorize, and it's gonna take me back. Dude, it failed to serialize the user into the session. What tech is that about? Um, maybe it's because I didn't say session is false, that's probably what it is. I feel like there's a session maybe here. No, oh, oh, maybe initialize I have to say session is false. I feel like there's some place I put I was not using a session, maybe it's on authenticate. By the way, what I'm doing right now is I'm literally just hitting control space on each one until I see the key that I want this is it. False. I'm like five percent sure that's what the. Maybe it's here as well. Session false because I have the serialized user code here, and this access token is an empty string that's maybe actually it wants me to put a real value there, that one of those things could be it. Um, also I can remove the code where we create a user in the logs comment that out. All right, now let's try that again. All right, off GitHub, so you notice like it just instantly we didn't go to that intermediate screen, it just says you logged in correctly one that means it worked. Number two that's just how OAuth works so if I've already authorized the app I don't have to do it again

And actually, this is actually kind of the syntax I prefer. Let's do JWT from JSON Web Token, and we'll say JWT sign. So, first is going to be anything you want to store in the token. We're going to store the user ID, which is just user to ID, and then we're going to have a secret. I'm just going to put a random string here, and then lastly, how long you want to last for. I'm going to say this expires in one year. So, uh, this part right here, you may want to add as an environment variable, and actually, I would suggest you doing that. I'm just going to hard code it here because I'm too lazy to go open up my.m and then edit it out. So, that's I'm just going to hard code a random value here. All right, so we have the callback here, and then if I come down to my callback here in the request, it's actually going to stick on the user. And why don't I just res.send? So, I'm going to just send back what the request.user is, and what you'll notice is it's actually going to be this thing right here. So, it's going to be an object and the access token is going to be assigned JWT. So, let's go over here and just authorize with GitHub again. Is it down? Is down what did I do wrong? Column GitHub of relation user contains null values. Okay, so what happened is I added a column here that I said that is unique and has to exist and it's a GitHub ID, but I already have users in my database. So, I have a couple choices. I can drop my database. I can and actually, there is drop schema. I'm going to say it's true. That's actually going to be the fastest and then it's working and I'm going to delete that now because I don't want to drop the data every single time and basically that just deleted all the users from the database and all data from the database. Okay, so now I'm going to come here, run this and let's do it and just let you know, let's do a thing and it crashed. No value in the column GitHub oh. So, in user.create, the GitHub ID, we need to set that as well. So, that's just going to be the GitHub ID is going to be the profile ID here. All right, let's try it again. Nice, so I can see I have an object back and I have the access token. Now, by the way, I'm currently using an extension to make this look pretty. I think it's just called like JSON format or something on Chrome, so yours may look a little bit different if you don't have anything for this, but I would suggest installing something if not. All right, so the last step of this is instead of just sending it just to the browser to show the user their token because they don't actually care, is to actually send this or redirect this back to the user. By the way, this is going to be access token that's the value we need. The TypeScript types are a little off for this, so I just do any on that. So, normally if we're just working with a website, we would redirect back to where that website is located, but because we're authenticating with an extension, the extension is actually going to have to start up a server that we can send it to and so I'm going to start up that server on localhost 54321 and this is something that will stay the same even in production because what's going to happen is the extension is actually going to start up a server on the person's local computer and then it's going to send the token there. So, this is correct even in prod by the way and here I'm just going to say /auth and I'm going to stick this access token and we'll do that save. So, now if I come here, right, it's going to at the very end of the process, it's going to say site not reached. That's expected, it's going to redirect us to localhost 54321 off and it's gonna have our token in there. So, what we need to set up next is on the extension side to actually read this token. So, I have the package.json open for our extension and the first thing that we're gonna do is add a new command and we're going to create a on not on but a authenticate command. Now, this is technically kind of optional but I like to do this just in case someone wants to re-authenticate using a command and they can call this and also it's just good for testing so we're going to add that and again we just have to come down here and tell VS Code that we're adding that and what the items here should be so this should be authenticate and I just call it authenticate here as well for the title and then in our extension let's go ahead and add one. Let's copy paste this one here and I'm going to actually create a new file to put the authentication logic because there's kind of a tiny bit of it authenticate dot TS and uh for now we'll just say console.log called and we'll call authenticate here

I think if I move my VS VS code up to the top level, it won't ask me. So, if you put all of your folders in the top level folder like I did, what you can do is you can move this dot VS code folder up to the top. Actually, I'm not going to do it right now because I think I also have to like fix the paths. Um, for this, so I'm not going to worry about it for now, but note that's something you could do if you want to go down that path. All right, so what's going on here? Engines is mandatory but must be type object. Um, we'll deal with that later. All right, so I'm going to run authenticate, and if I come to debug, it's called perfect. All right, so step one and authenticate is going to actually send us to our API and take us to that URL that we were clicking right. So, in our browser, when we were going to 3002/auth github, right, this was step one to launch. So, we're gonna do that same thing from VS code. So, what we can do is we can import from VS code, move this over. Um, is it command execute command VS code.open. Um, and then we are going to pass a ure for this vscode.yuri.parse and then a URL. So, this is the syntax the tell VS code to open up a URL basically. So, we call execute command and then we say VS code open and then here we are going to pass a URL and notice we have to parse it. This is just how VS code handles different URLs. You have to uri.parse on it because you can actually pass different things than just URLs here, but URLs is the only thing I've actually ever used. Now, I can just paste in my. Oh, I thought I had pasted the euro from here. I can just paste it in like this and this will work perfectly fine. But one thing that I like to do is create a constants file and do an API-based URL, create a variable called API base URL. The reason being is later down the line, like when I go to production, I may want to change what this value is and so it makes it very easy to have one location for this. All right, so then I'm going to put API base URL here and we'll save this as well. All right, so if I come back over here and I reload this and I do authenticate, so you notice it took me one back to my browser and then also you'll notice how it took us to the redirect so that's perfect. Now we need to actually listen for this redirect and get the token from it, and by the way this is one reason why I usually like to use sessions, but for this it's not easy to use a cookie slash I'm not sure if you can even use a cookie at all to get this to work. We need to pass the token in the URL like this so, JWTS are just a little bit simpler in this case so that's why I'm using that. By the way, but so yeah, so we just need to listen for this and you may have been like prompted to accept something when it asks you about authenticating like hey are you okay opening up this URL, that happens the first time and then after the user says okay it doesn't ask anymore. All right, so let's go back over to our code, mine's over here. So, how do we actually listen for that URL? Well what we're going to do is we're actually going to start up a server and listen for a request. Now, usually I would use express for this but since we're using webpack to compile or bundle everything it was not trivial slash I didn't know what setting I needed to add to get to play nice with webpack so I just switched to a library called polka. So, I'm going to import polka from polka and it's basically just a lightweight version of express. There's really no reason for us to use express in this anyway since um we're only doing a very simple server we don't need any middleware or anything like that. So I'm gonna install polka here actually not here in my API no my extension. Um, let's just pull up the docs for polka while that's loading. So, this is what I'm talking about here and you'll notice these syntax is very similar to express so if you use express before polka is going to be very intuitive and let's install the types as well. Copy this. All right, so I and I actually like to initiate the polka server before I um open the URL just to make sure it's all ready. And is it not happy default export? I'm just going to tour to our TS config over here and add default allow synthetic default imports to true. Um, I'm thinking that might fix it. It did, cool. That just allows you to import it like this and I like using this syntax. All right, so we're going to say app is polka um and at the very end here we are going to listen for five four three two one, right, so you'll notice this is the port that we are redirecting to. All right, so what we're going to do here is if we got an error we are going to display the error message so window dot show error message on air dot message otherwise after we start up the server we are going to send them and complete the auth process um error has to type any okay

And if I go back because I I did forget and where are we redirecting I called it slash auth and then we're gonna have an access token, okay. So slash auth slash colon token. All right, so I can get the um, so you notice I put a colon here. Colons are variables so this path can take any value and it's going to store it in a variable called token for us. So if I say rec.prams prams is going to be an object that we can destructure and get the token and notice the names line up. Now if we do not get a token for some reason, we can just return but we can say res.end and we say something went wrong, and you notice I'm just sending some HTML back to the browser since they're in the browser. Um, and then here I'm just going to console.log and see if we get a token and then I'm going to say res.end. Auth was successful, you can close this now. And yeah, let's go ahead and reload this and test that out so if this works what's gonna happen is we should actually see some HTML authenticate result in error running contributed command authenticate failed running they can oh my authenticate command failed. I thought my servers failed to start up, I'm just gonna do a hard reload because I'm not thinking that should crash we don't need that okay authenticate, are you serious oh there's probably an error happening in here going to try catch it and then my console log the value because it wasn't giving me like a stack trace or anything, so let's go to debug console. All right, this is perfect so polka dot default is not a function. Oh what does it want me to import it like this, we'll reload up yep now it's working so I guess I needed to do different syntax and I thought my ts config maybe I have to do like uh yes module interrupt true to be able to get that to work but anyway we got it working so I'm not going to touch this part and that's good but yeah you'll notice how I redirect this back to rh1 and said auth was successful and if I look at my debug console I actually see a token here so the idea is if I yep in our in our code right here we now can use this token and save it and this is how we know who the current user is

An or so, this value can either be a string or undefined, and this specifies what this method returns. So I'm saying that it returns that and it couldn't infer it because VS Code doesn't know what we get we might store there, so I guess you could store more than just strings. Personally, I've only stored strings in there, but note, this returns a promise. Update is a promise. Git is synchronous.

All right, so I'm gonna open up the debugger. I'm gonna reload my extension and while I was expecting it to tell me that token value is empty, let's clear this and reload again. Wait, why, why isn't it showing my console log? I don't get it. It's not calling this for some reason. All right, well let me put this in my hello world. Oh, you know what, let me just verify that it's recompiling. Maybe it's not recompiling in the watch flag. No, it wasn't recompiling. I have no idea why the console log wasn't showing up. So I'm just going to stick it in my VS to do hello world command. I'm going to comment out this create show panel and instead, let's just show a little pop-up and we'll do a plus sign here. So I'm just going to display the tip, what the token value is in a window. All right, so we'll reload and I'm going to say hello world. All right, so cool. So the token value is currently undefined. So now let's authenticate. It was successful, I can close the window now. And notice how when I call hello a second time, it actually has our JWT in there. And the beauty of this, if I reload the extension and I call hello world, the token should still be there. And sure enough, it is there. So we now have a token stored on the user and it's going to persist as the user closes VS Code and reopens it, and so this token is what we will use to make sure the user is authenticated and every request we send to our API now is also going to send this token, so that's what we're going to set up next. So back at the index file for API, we're going to be adding a new route. Now that we know or can store a token on the user, we can use that token, send it to our API to get the current user or do any kind of authentication that we need to or like create authenticated routes. So we're going to start off with a simple one here called a Me route, and the purpose of this route is for us to be able to call it and then get the current user. So what we're going to do is send the token that we get in a header, so here I'm going to say token is equal to rec.headers.get. Actually, we don't have to dot yet, we can just say dot, and I'm going to say authorization. Now the standard format for the authorization header is something like this. It'll say bearer and then I'll have the token value like that, so what we're going to do is here we're going to say auth header. If we don't get an auth header, we can send back a null user, and here this is the token is going to be the auth header and we are just going to split by space and you'll notice it automatically did a question mark, that's because I forgot to put a return value here, and now we don't need the question mark because we know that this is going to be defined and this is going to be the second value so, first index. And again, if there's not a token, we can return a null user, otherwise if we have a token, we now want to do something like this. User.find1 and pass in the id of the user. So and we also need to make this async. So how do we know the id for the user? Well, because we have this token, what we can do is we can get the payload from it, so we can say try catch and reason why we're doing a try catch is because the JWT verify function will throw an error if the token is not valid, so in that case, we can also return a null user here, and then here we're going to pass in the token, the secret. So the secret is whatever we used the string that we passed into our wt sign. Now I went and put this in environment variable while you guys weren't looking so I was a good programmer, so go ahead and take whatever you chose to put here for the secret down here as well, um and then I don't think there's really any options you need to pass in here for at least verify for us, and we're going to get the user id from that because that's what we stored inside of our token right here. User id and actually usually how I do this is that's going to be the payload and we'll say let user id is equal to payload.userid and if you just hover over this you can see it's a string or an object. I'm just going to cast it to any or not cast it I'm just going to say it's type any. All right, so here I can do one last if check if I want if for some reason we did not get a user id again we can return no user otherwise we can look up the user and return them here. Res.send the user

And uh, let's do sidebar. By the way, I don't know if I mentioned this, I probably did, I just did command space and then started typing to come over here to the sidebar component. All right, so in here now, I want to fetch the current user and just like display them, right? So, I want to call that me route. Now, in Svelt, you can just add fetch. You can just use fetch like this and I like to stick it in on mount. Now, there is some stuff I've seen where you can actually just store a promise and deal with that and load it, there's like a special syntax, but I've actually found that it's less helpful when your application gets more complex and it's better to just do something like this, where you set loading equal to actually true by default and then when you're done fetching, you send set loading to false and we're going to put this down here. I want to set the window event listener first, so this is going to make async and here we're going to say oops. So, I could just hard code http logos 3000 to and put the mirror out, but this is a case where I'd really like to use the constant API based URL that I have right here. So, what I'm going to do is in my sidebar provider, actually just pass that in. So, you see how we are just passed a global TSVS code here, we could do the same thing for like the APA BC, the API base URL. There we go, and I just want to make sure I spell it correctly, I did, sorry, I've just been like slurring my words for the past like two seconds here. All right, and we're going to say JSON.stringify and we're going to import this. A reason why we do JSON stringify is just to escape this and put quotations around it to pass it to this value. Now we can also enter pages, actually not pages globals, add API base URL as a string. A reason for this is that we know that this is it's going to be const as well, that way we can access this like if I didn't add this, if I tried to access the API base URL, you'll notice how there's no auto completion, it doesn't know it exists, but as soon as I add that API base URL is a thing. All right, and we're just going to do this. So, we're going to await the response and this should give us a user and we will await that as well and actually why don't we just, we'll say data because what I'm going to do is I'm going to say user up here is null and say oops user is equal to data dot user. All right, so after we have fetched this, wait, back should be capitals there, we're just updating the state here and this will re-render with the values. So now down here, in my to-do's and all this stuff, what I can do is I can add an if statement so to conditionally render so if you do hashtag if and Svelt, I can say if loading and then this is how you do if statements, you do this slash if down here with brackets so if we're loading maybe we just say div loading dot dot dot. Else, actually I think it's just colon, yep, not else else if we have a user, then display a pre tag and let's display the user. User has implicit titan type any so why don't we say it is either null and I think this is everything on our user a name and just an id um, otherwise no user is logged in so these are the three states that we can possibly be in. Now, if I were to run this code right now, it's always going to return null, so if I reload, open this up. Okay, loading, wait, is it crashing? Oh, you know what it is crashing. All right, so if I go to my web view, developer tools, all right, yeah we actually have two errors here so we have a chorus error which actually I wasn't expecting us to hit the coors air yet, um, I think so maybe after we get rid of this coors error we're gonna get another error after this but let's fix cores first so access to fetch hbo closed from origin has been blocked by course policy, no access control allow origin alright. So on our API we are going to install two packages well one package cores and then the types for cores. So, npmi with the d flag types course and then let's go over to the index file over here and we're going to import course from course and by the way I switched to the index in our API and all we're going to do is in our app we're going to say app.use course and we're going to set the origin to localhost. Wait, what am I doing? What is going to be the local host origin access to fetch like this is a VS Code extension, oh is this literally what I set the course to oh, you know what I don't even know what I would set the course value to, I'm just going to put a star, I'm guessing this is the origin it does say from origin and it gives me it right here. All right, so if you want to just do your VS Code extension, I guess you could do this and copy this value here. I actually have not tried this, I think in all of mine I've just done core star for VS Code extensions so that's what I'm gonna set here

And this is my API logs good listing on 3002. I'm going to control R to reload and yep, looks good now. All right, so it says no user is logged in, which is expected, and even though I am logged in, technically, right? The reason why it thinks I'm not logged in is because I did not pass in an authorization header, right? So headers, authorization, and here I need to put bearer, and I need to put my JWT right here to get the current user. And again, I can put a bad value right, and that's still going to tell me I'm not logged in, right? User not logged in. I need a good token to pass in here. So where am I getting my token from? Well, we have the access to that token. One possible way you can do this, and I've done before, is just pass it in here, access token is equal to json.stringify and pass in the token manager. I get token. So this works, and I can again add a global access token which is a string and I can pass my access token there. And now, if I reload this, oh, we'd be crashing. I was not expecting that. Access token is not defined. Axis token. Oh, so you notice how I just reloaded my web view but I didn't reload the extension because I made a change in sidebar provider, that's the extension, so I need to do a full reload, okay? And now, I should expect a user. Nice, there I am. Also, there's my GitHub ID. Nice. Now for the first version of my VS Code extensions, this is actually how I passed in the access token, but I don't do it like this anymore. And the reason is, is it's hard coding the token here and this value never changes, right? What I really want to be able to do is be able to get the current version from token manager whenever I need an application, because what I ran into is you'd be able to log out, and if you log in again, you really need to be able to reset this token and whatnot, and uh, it's not easy if you do it like this. I could set let, but there's going to be some problems that you run into, so to avoid this headache basically and just I just don't do it this way. Instead, what I do is in the sidebar, I'm going to send a message to my VS Code extension telling it that I want some tokens and basically I just store the access token as a variable so access token is equal to an empty string like that. So, I'm going to get rid of it at this global context and just store it in a Svelte variable. All right, so I'm going to say VS Code or TS VS Code dot post message, type git token, and that's actually all I need. So this is just me sending a message to the extension telling it that I want its token, and then what I do is I'm going to make a new case to listen for token, and what this will give me is message.value is going to be the token and then what I could do is I can set my axis token is equal to that. I don't know why I made this uh, intermediate token here. We're going to do it like that, and then also what I can do is uh, this token that I get here is kind of I'll initially fetch the user as well, so I'm gonna put this logic here and we will get rid of Nope, this looks good. I think it's mad at me because I didn't set a value. So if I go to my globals over here, I'm going to say value can sometimes be undefined, wait, doesn't like my question mark or undefined, wait, why is it acting like that? All right, I don't know why TS TypeScript is acting like that. I'll just pass in a value of undefined, and it can be happy with itself. All right, so let's finish this up. So this is going to be async, that way I can do this here. All right, so I trigger git token. I need to actually add this on the extension side, but the gist of it is I'm telling it to get me a token. Once it sends me the token back, then I'm going to fetch the user and display the user like this. So now over here, I can remove this access token variable that we're passing in and instead listen on this so here it says get token that's what I used, right? Um, yep, get token, and here I'm just going to then send a message back, so webview.webview.postmessage and how did I structure this again, this is going to be type and then the value is the token so type token and the value is going to be token manager.gettoken. All right, and it's going to pass the value to the access token and then we're going to use the access token to fetch the user. This looks good. All right, so let's give this a try and make sure everything is wired up correctly. Again, let me just go over this one more time of how this is working so when our Svelte component mounts for the first time is going to send a post message to our extension and uh, it's going to pass in the type git token that's going to come over here and it's going to receive the message git token

And notice with the setup, we can now call git token whenever we need to basically refresh the token or get a new token. And so that is the advantage of this method.

Yeah, let's come over here. We made some changes to the extension, so we're gonna have to do a full reload. And let's see if it tells us that we are Ben. And it tells us we are Ben, so it does work.

Um, so basically we get the same end result, but now at the beginning, it's going to send a message back and forth real quick to get the current user.

Next, I want to add a button that we can actually log out and that we actually keep track of the state if the user is logged in or not, we can show them a button to actually log in or show them their to-do's.

So, what we're going to do is just come up here and keep note of our user. So our user can either be null or it can be an actual object, or we may be loading. And so that's how we're going to keep track of what state. Now, if we had a bunch of other pages, we may want to create a page variable, but I'm good with just this for now since we have simple state.

So what I'm going to do is I'm going to actually move the logic for to-do's into a different file, so I'm going to create a new component here called to-do's dot svelt, and I'm going to copy this entire form and we don't need these buttons at the bottom anymore so I'm going to remove those, and it uses some text so we'll copy that.

Alright, also, we need to do soups, I copy too much. What the heck is this auto completion? Alright, to-do's and we're good. So, I just moved the logic over and we can now render this to-do's component over here.

Um, so window.add event listener was for adding a new to-do, so we're actually going to copy our unmount and put it over there as well. Don't need this and I don't need to listen for the case where there's a token and we need to import on mount. And now, I don't care about the new to-do here.

Perfect, we need to move this style over as well, paste that in. Alright, so here if we have a user, we're going to render the to-do's. And why don't we pass in a user as a prop? So this is how we pass data to components and salt.

And to actually get that value, we can say export let user. And why do I create a new file here called types.ts? Export type user. And just so I can use that in all the places. And I'm going to replace this object with my user. And by the way, um, just typing user and hitting enter was uh, autocompleting this for me. You'll notice we have to do import type since it's a type.

So now let's just display the user. Was I using a pre-tag? Yeah, I was using pre-tag there before. Why don't we do that? Just or not pre-tag, but just the name of the user maybe at the top. I'll just say hello to the current user, capital H, why not?

Alright, so we're only going to show that if there is a user and maybe we also have a log out button at the bottom. We'll fill in the logic for this in a second. Also, a button here called login with GitHub. So when this is clicked, we're actually going to post an event, and actually do we need to post event? I was going to say we post an event, but we can actually make this a link. Let's make this a link instead of a button. Actually no, I'm wrong. So okay, this was the logic that was going through my brain. I was like, let's make it a button, then we'll post a message to the extension and tell it to authenticate, but then I was like, do I really need to do that? I could just create a link and take us to the website, but we actually really do need to do the button because I need to call my authenticate function. So it does this entire thing where it starts up the server, so actually it's going to become button again. Welcome back.

Alright, so we're going to say this and authenticate, and all we're going to do is listen for that on our sidebar provider over here and called the authenticate function that we already wrote so nothing else we need to change there. It auto imported for me, awesome.

Alright, so it's now going to do loading our user or this let's just verify that this is working so far and just do a full reload and then to verify that our log out or not to verify we actually need to code log out next so it should show me a current user. I feel like it crashes, it shouldn't be this slow.

Uh, failed to connect Locos 2000 slash, really? Did I stop my API? I did. All right, let me restart it. Okay, now we're good. So it says hello there and I can type to-do's. Wait, it only let me do one to-do. Do I crash again? Can I have duplicate keys? Oh, I typed the same word twice trying to do random letters. Alright, yeah, we're good

They're not going to be, we want to get rid of that if they've logged out. All right, full reload. Oh, and the other thing, if I go to my, I need to call git token after authenticate is complete. So what I'm going to do is I'm going to click to our authenticate and add a callback function. And actually let me explain this for a second before I do that. Basically, after we're done authenticating, I want to call git token to send the new token that we get from authenticating to svelt. So to be able to do that, I want something like this. Oops. And do this and send a token back, but to do that we need to change our authenticate to actually take a function. So this is basically the callback whenever we're done. So this means we got a token, so we'll call the function here. All right, and you know we could actually do that before we close the server because closing the server is not that really important. This is really the main thing we do it after the token set. All right, so let's test it out now. So we're going to log out then it should show us a login with GitHub button. All right, and now if I press this this should take us to the browser log us in with GitHub. It said auth was successful. I come back, I now see my hello Ben. So awesome, so we can successfully log out, log in. And let me just Alt R, it's still logged in as been, so perfect. So there you go, that's the process for keeping I guess off state for the user. Now that we have that all set up, I want to add a to-do entity or to-do table in our database to store to-do's on the user. And now we can use that jrot token and send that in requests and we know who's making requests and so we can know who's creating to-dos and we can fetch to-dos for certain users. So in the entities folder for our API, I'm going to create a new file here and I'm going to call it to-do.ts and then inside of here, I'm going to copy our class, the user class, and just paste it in here, and I'm going to call this to-do. I'm going to keep this id and we're going to have some text which is not null, it needs to be a thing, and then also value called completed and it's going to be a boolean, and this defaults to false. Now I also want to know who has created a to-do, so we are going to set up a relationship. This is going to be a many-to-one relationship with the user table and this is just going to be basically the creator of the to-do or you could call it owner. And so this is going to be a user and the type is going to be a promise that returns the user, and then just be capital p. All right, so yeah, if you've never used TypeScript before, again these are just all the types for each field, so number, string, string, and then generic is when you use this bracket like this, I'm saying that this is going to be a promise and that promise then returns a user and so we could also put other things in here like a number and whatnot so that's a special type that's called generic. All right, so we're going to pass in our user here and so for main to one what we do is I believe we're going to be given a type function or target yep so this is going to give us a user and actually no I think we pass in just a user like this and then we're given a user and then we're going to say to-do's so we need to set up a field on our user just so TypeORM knows both sides of the relationship. So here I'm specifying the entity that this is related to, in this case a user and then here I have to say the field so the field in this case is called to-do's. We haven't set it up yet, that's why it's barking at us but we're going to add that in a second and then this is just a function for both of these is how the syntax that TypeORM wants. So then over here, again notice how this is many to one. This side of the relationship is going to be one too many, one too many right and so this is with to-do and to-do dot creator and so I'm going to call this to-do's and this is going to return a promise of to-do and this is actually going to give us an array right because I can have more than one to-do as a user and so the name here lines up with the name over here and then I'm going to create a column for the id, so I like to just say join column and then give it a name, creator id, I like to be explicit about this, and I can say column creator id, you can think of this kind of like a fake field that TypeORM uses, this is the actual field that's going to be stored in the database, and so I like to just explicitly add this on my class, you don't have to add this but I'm going to use it I'm going to fetch it so I like to have it there. All right so now that we have this we can in our index for the API start using it so I'm going to create a new route here let's actually put it below our off method

And here I want to say to do. Create. And here I want to pass in basically the values to create to do. In this case, I'm just going to say rec.body so to take the data from a post request, I can get the body of a request and that's what I'm going to use. I'm just going to pass it directly into create. Now you may want to do some validation if you were in production. So you may want to say like direct.body.text.length is not greater than a thousand or whatever you want to do to check. But I'm just gonna keep it simple and send it like that. And then I'm gonna send it back by saying res.send the to do. And I need to make this async and did it import it? Yeah, it imported it. Why is it not letting me save? Um, this is possibly it's not exist on the type. Array of to do what. Why does it think it's an array of to-do's. Oh, I think create. I think so that's going to return an array of it why. I think I think it's just overloading the wrong thing so what I'm going to do is I'm going to say as a single to item and the type is going to line up. So if I command click on create, I can see that there's multiple different types of create

All right, this looks good. So, if I made it all the way down here, we're going to save the user ID, which we get from the token, which we get from the headers, and store it on a request ID. Now, this is not happy with us because this type doesn't really line up. I'm just going to cast this to any for now. Actually, do I want to? Um, maybe I do it like, no, I'm going to cast it to any for now. But what I'm going to do is I'm going to create a new object or new type called 'rec' with user ID, and all this is going to be is this new 'rec' object. So, by default, if I hover over this, it's going to be a request. And actually, let's take the whole thing, take these, and we're going to say 'and user ID string'. So, I'm creating a new type by concatenating this type with this type. Request is not generic. Do I need to say 'express'? There we go. We just need to import requests from express. So, if you've never seen this before, how this works is, if I do like 'user ID string', and uh, 'user ID 2', or we'll just say 'user 2', there's also a string that's equivalent to me just having a single object that looks like this, right? So, it takes these two objects and matches them together. So, this doesn't necessarily look like an object, but it is. It just has some generics passed in. So, now in my index over here, I'm going to say 'isAuth', and I'm going to say 'rec' with user ID as my type there, and here I'm going to say 'rec.user ID'. And let me first see why this is mad, and then we'll fix why the other one's mad. Um, type is missing following properties from type to do. Oh, it doesn't like that. I'm casting it to to do anymore. I don't think we really need the cast. Do we just, not string is not type. Oh, the user ID here needs to be a number. I forgot that our user IDs are numbers, not strings. All right, so that's happy. I'm guessing this is not going to be happy because this request with user ID changes. It's going to tell us the types don't line up. Yes, so I actually don't know the best way to fix that. I used to just do this, but I wanted to be nicer and have like a nice object that knew the type. All right, there's probably a way to fix this, but to be honest with you, I'm just going to cast any for now because I don't want to deal with it. So, I guess we don't really need our type over there, but it's whatever. But yeah, notice we are getting the user ID from the request object, which the isAuth actually is going to stick on there for us. But if I try calling this without being logged in, it's going to stop us, so that's perfect. All right, so let's test out our to-do, and let's go to our extension. And so now in our form when we submit, instead of doing it to do like this, we want to send a post request. We still want to blank the input though, so we'll do that. Put down here. All right, so we're going to say base URL, and here we're going to say the path is just to do. The method is going to be a post request. The body is going to be JSON, and we need to stringify it, and the text is just going to be text. And oh, you know what? We actually need to put this afterwards, that way we don't clear the text before we do this. I'll make this asynchronous. I need to pass in my auth header like I was in my sidebar over here. So maybe I need to pass this access token as a prop. Um, by the way, this syntax, if the prop's name lines up, you can do it like this. And this is just shorthand for this. So you see how the names are the same, so if I save it, Prettier is going to automatically make it look like this. All right, so back at our to-dos. All right, so we're sending a post request to here, we have our authorization. Oh, headers should be here, not inside the body. And then here we're going to say to do is equal to await response.json, and then we are going to update our to-dos, passing in our new to-do. Okay, so let's give this a shot. I'm going to just Alt-R my extension, and I'm going to say first, hit Enter, and it probably crashed, so let's open up the web view and see what we did wrong. I'm going to look at the network request. Enter. Um, pending. Oh, does it never respond? Our server's crashing. No value in column text. The relation to violates not null. All right, let's see what we did wrong. So, I'm passing in rec.bio.txt. Let's do a console log of what the rec.body is. All right, let's hit Enter, hit Enter again because I didn't let it reset. Wait, what? Oh, you know what? No, I just messed this up. I actually have another server started up on 3002, I think. So, let's do, so this is the command you can do, at least that ID to see what's running on port 3002. I forgot I started up another, I started create React app um, so it's going to be this one. So I can say kill that ID. Now we only have one running, perfect. Wait, I just control seed. This shouldn't actually be running either, let's kill it, why not? All right, so I killed everything that was running on that port, and now I'm going to restart it, so yours actually might have just worked. All right, let's run it again

Actually might have just worked. All right, let's run it again. There we go, now it's actually posting to the right place. All right, so let's see what the request body is. The request body is an empty string. Oh, I'll tell you why. I know why. It's because I didn't specify the content type. Content type, um, how do I do this? Is it content type like that? Application/json. I'm like 96 percent sure this is the header you're supposed to pass whenever you do JSON data, but I might need to look it up if this does not work, but that's definitely what our problem is. All right, depending on need ALT R to refresh it. Oh, nice, first, shut up. Uh, so notice how we are actually getting an object that says text. First, now yeah, so you just need to tell the API that you are sending JSON data because if you don't, this does not work. Our Express JSON parser here does not actually parse out unless you say you're passing in JSON. All right, cool, so it's actually sending the data to the API. IsAuth is making sure that we're logged in and it gave us the right user, and it's actually creating a to-do. Now, now if I refresh, my to-dos go away. So next we want to actually be able to fetch those to-dos from the API as well. So jumping back to our index file on the API, we're going to do a GET route here. I'm going to say app.get and I'm going to say slash to-do. It's totally fine to have these routes be on the same thing, but they're doing different methods like this is GET and this is POST, so that's okay. And I did backticks here for really no reason, so let's go back to single ticks and then let Prettier make it double ticks, and so we're going to say rack res, and this is another place where I need to know who the user is and I want them to be logged in, so I'm going to be using my isAuth middleware here, and I'm going to say rec.userId, again, to get the user ID, and I'm just going to cast this to any, and I'm going to say to-dos is equal to await to-do.find I'm going to say where, but let's make this async, and this needs to be to-do async because we're doing a wait, and this needs to be creator ID. There we go, I was just waiting for Prettier to format things to make sure my syntax was right. All right, so yeah, so based on the token, we are going to get all of the to-dos that you've ever created. I'm not going to worry about pagination for this, and I'm going to say res.send and send those to-dos down. So now we can call this endpoint from our to-dos.felt, so let's stick this in our on mount and we're going to just populate this to-dos array when we get the data. So I'm going to copy this response because it's kind of similar-ish. All right, so here we're going to hit to-dos. The method here is going to be GET. If we don't specify a method, it's going to get by default, and again, make sure to pass in our header. We're not doing a post request with JSON data with a body, so we don't need to pass the content type, and this should give us to-dos and I'm going to call this payload, and I'm going to set to-dos equal to payload.to-dos. All right, so I'll come back over here, reload it, and you'll see my titty is there, so I'm going to say 2, and I can reload it and it is there. Now you notice the order is kind of interesting. I don't know how I want to do that. Don't inverse the order because what I can do is I can say if I want to keep the same order in my, oh, not this one, and the find here, I can say order by and we're going to say ID and we'll make it descending, and I think that should have 2 on top. Perfect, so now if I do 3 and I reload, it's in the same order. I just want to make sure that they lined up. Now in our to-dos and felt, the only other thing that I was going to do here, there's one other thing I wanted, oh, yeah, the ID. So right now if I do like, for example, 3 and I already, you know, it didn't show up right, it's because we already have a 3, and if I open up the web view, it's going to complain about duplicate keys, and that's because I'm using the text of the to-do for the keys, but I don't actually need to do that anymore. I can use to-do ID and I need to add an ID to my to-do, of course. ID is a string. Hey, what am I doing this number? There we go, um new to-do. I'm not going to worry about the, I mean, I guess if I really want to worry about this, worry about the new to-do that happens here in a second, we'll fix that. I'm going to just comment it out for now. All right, so if I reload this, it now shows up and I can do 3 again. That's because it has a unique ID now, even though the text is the same. So that's all good. You notice I can cross things out, but again, I'm not storing that a database right now or at least persisting it to database or it's letting the database know, so if I reload it, it goes away

So, how can I do that? Well, you can copy the logic here to create a to-do and stick it in here. All right, so text is actually going to be message dot value. Other than that, everything else in this block is the same. I could even refactor this into a function if I really wanted to. So, why don't we try that? Add to do, and it's going to be an async function. Um, I was going to put text here, but I didn't want it to conflict. So, text is what we're going to pass in, but let's call it t, and this is going to be a string. Copy this bit, paste it here, and we're going to pass t here. So now, I can call add to do here, passing in message.value, and I can also call add to do down here, passing text. Now, I could await this if I wanted to, but I actually want to clear the input right away, I think. So it's doing alt r. I'm going to copy this and push add to do, and now it sends it over here. Awesome. Again, just going to make sure it persisted. It does. I reloaded it. We should also test out our authentication middleware and just make sure if we don't send a token with this request, that it doesn't actually send us to do's back. So, what I'm going to do is just comment out the authorization, not on the add to do, although that we could test it there too, but I want to do it on this one. When we fetch, I'm just going to save this, come over here, and I'm going to reload the window and sure enough the to-do's do not show up. So, perfect. So then, like the API, knowing who we are, is all based on the token that we are sending. Now, I'd also like to persist the to-do's, like when I press it and cross it out. So right now, if I click these and I refresh, it's gone. So, we're going to add in our API a new method here, and I'm going to use put. The put method, since we're doing an update, and again we're going to keep the isAuth portion here, and I'm going to in my request body, instead of the text, we're going to say completed and just flip it from true to false. And we also need to do an update. Now, what I'm going to do is just keep this simple and fetch the to-do. So, I'm going to say wait to do.findOne, so we need to pass the um id of this to do that we actually want to update in the body. And then I'm going to say to do.completed is equal to to do.completed and just the inverse. And then I'm going to say to do.save. Now it's putting these question marks everywhere because cadoo or to do can sometimes be a null, so if we do not get it to do for some reason, I'm going to send back the updated to do as uh null, and I'm going to get rid of the question marks. Now, we don't need those since we have this if check here. Now, what is it not happy with? Type boolean is not assignable to type string. All right, so let me click on my to do here. This should be a boolean. All right, now go back. Now this is typeform syntax, I think I use it above as well. We can just change the value on the field after we fetch it and then we can save it. Now, you could probably write this in one go with to do.update and I believe there's a return syntax, but I don't want to get too involved in that because we're going to do like a query builder for that. I just want to show some simple stuff for this. And, uh, we're just going to return the new to do back. So this is a very simple way you can do your updates. And now, if I go to my to-do.view, we are just going to do instead of to-do.completed, call our API. Well, we're going to do this as well, but we're also going to call our API. So, we're going to say API base URL, and here we're going to say method put, body JSON.stringify and put. Basically works very similar to post, and this is just like a REST convention. You could do if you want to, you could just make this a post request too. So, we need to pass the id of the to do. And was there anything else I passed on in the body? Nope, that was it. Headers. And I'm going to copy the headers that we're using for add to do because they're the same. Hey, this looks pretty good. I'm going to make this asynchronous. Actually, it's going to be response, and we can array response.json. And I'm just going to console.log it. We don't really do anything with the response. We could update the to do completed, but we're already doing it here. So just gonna refresh the webview. I'm gonna click this, refresh the webview, and it's still there. Nice. And let's toggle it back off. And we can add another. Click it, refresh. And that's looking pretty good. Um, so there we have it. We can now do update. And I think you guys get the gist of how we add more and more functionality to the app. We can add more API endpoints. We can add our authentication middleware in there for the ones that need to be authenticated. And then we can make fetch calls um from our svelt code and send the header to auth and uh, that's how we also get the user

Right now, anyone can edit a to-do, right? So if to-do dot created at creator id is not equal to request.userid, this is just some authorization logic to make sure that the person who owns the to-do is the only one who's editing it. So, I'll just say you're not authorized. So if the id on the to-do does not match the current user based on the token, we're going to say not authorized and throw that. Now, normally, I would test this, but I'm feeling kind of lazy and the focus of this is not backend. It's VS Code extensions, so I'm going to leave this as an exercise for you if you want to like go log in with another account, create a token, and then use that token and try to update it to do. To test this out, go ahead, but I'm feeling pretty confident about my logic right there, so I'm going to leave it as is. Now, I want to go over one last concept for VS Code extensions. So, in our to-do's dot svelt, right now we kind of just have one page, and that's totally fine, but let's say we want multiple pages. One way I could do that is actually let's go to our sidebar, because to-do's might be a page, right? So let's say we have a page um variable, which we just store the current page in. So, for example, this can either be what the heck, this can either be to-do's, or it can be uh, what do I want my other page to be? I'll just call it contact. And, by the way, the reason why I wrote my TypeScript type like this is because I can now get autocompletion. So, if I hit control space while inside this single quotes, it'll auto complete these two options. So, by default, I'm going to have it display to do's. And then, down here in my code, I'm going to have an if statement. If there's a hashtag, if the page is equal to, and I'm going to wrap the to do, if it's equal to dues, I'll display to do's otherwise we'll do else contact me here, right, whatever. So, just pretend this is a really cool page, and then we'll have a button down here that says on click, and this is just so we can navigate. I'm going to say go back, and all it's going to do is it's going to set the page to to-do's, so we can go back after we go there. Now, if I come to my extension, just do a web view reload there. Oh wait, I need to add a button to go there as well. So, on this dues page, go to contact and we'll set this to contact. Alright, save it. All right, there we go, so I can press this to go to contact, I can press go back to go back, right, all right, so we have like a little bit of a page set up for us to switch pages. Now, here's the thing. I'm on the contact page right now. Let's say someone closes the sidebar and then reopens it. You notice the sidebar changed, right? It's now on the to-do's. So, by default, it's going to recreate your web view every single time. Now, you may want this behavior if so, you can just keep it as is, but for my application, when you went to contact and you closed and reopened, I wanted it to open and have the contact page shown. So, the way that you can actually get it to work is by keeping track of the state and the page that you're last on. So, if we use the TS VS Code, there's actually two methods we can use on this, and I'm actually just going to command click again to go definition and add the two functions. So, there's a function called state, which returns, it's a function we can call and it can return whatever we want it to return, and there's set state, which takes the state, which can be anything, and returns void. So, the idea is in our code, we're going to call set state and then whenever we reload the panel, if we call get state, whatever we last called set state with, will be inside there. So, one way we can do this is and felt if you do a dollar sign like this this code block here will be called every single time uh whatever variables you use inside of your change. So, what that means is I can say TS VS Code set state and I can save the page. So, every time this page object or not object but variable changes, salt is going to automatically rerun this code and it's going to set the state, so it's going to persist this. So, what I can actually do here is I can say TS VS Code copy this dot get state now this may be undefined if we don't have a state so I'm going to do a question mark and say dot page, and if we don't have a page then I'm going to set it to to do's. So, when this first loads, we're going to check if we have a state for it, if not we're going to take to do's and then after that whenever we navigate pages it's going to save this and again this will work for any number of pages. All right, so let's test this out. I'm going to reload it, I'm going to go to contact, I'm going to close my panel, and then I'm going to reopen it and you'll notice contact stays open

Client state, it doesn't just have to be, you know, the page. You might have someone filling out the form, right? So, I might have some text in here, but if I close and reopen, it's gone. So, for anything that you want to persist whenever this is closed and reopened, you may want to store in this state. And then reload it like this. And basically, you're going to do this exact same behavior. You can stick any variables you want in a block like this and save it.

I also wanted to jump back to the API for a second because someone sent me a snippet on how to get the types to work with Express. So, I don't know if you remember earlier in the tut, we were trying to get it to work with this wreck with user ID, but this is like the wrong approach. So, I'm just going to kill it, goodbye. And instead, we're going to like extend this request object by creating a type. I'm going to say new and I'm going to say extend - express.d.ts and we're going to say declare namespace express export interface request. And basically the names are going to line up, express is a namespace inside of express and if I command click and look around, I should be able to find it, there it is. And request is also inside of there and you can actually see us importing it, so this is us adding a property to this interface. So, I can just say user ID, user ID, which is a string, and now it's just going to be there in all of the objects and also we don't need this and our is auth anymore.

Alright, so now what does this mean for us? Well, enter is off now. You know how I had to do like rec dot as any because this is not on it? I don't need that anymore. It's now just happy. And you know, in my index file over here, where I had any, did I not set it to any? I thought I did. Yeah, I did. Oh, I put a space and you put a space. By the way, that control f or a command f is how you bring up this and you can actually search if you need to in VS Code. Alright, so, uh, this doesn't need to be there anymore. Well, okay, this one does, because this is just a random access token. Sorry, this is going to be the request object, yes this. Well, this one we have to set the any to, okay, this is the one I'm specifically talking about, we use request and we have the user ID, this one there. Alright, so user ID is just going to be on this object now, at least as far as TypeScript types go, so we do not need these. Um, oh, so if you, if we look at this, oops, I think it's going to tell us that, yep. So, by the way, usually when I get, I'm sorry, I'm scrolling way too much, so usually when I get a TypeScript error, you'll notice what I've been doing is I'll actually scroll down to the bottom. So, personally, I find that's actually where the useful information is. Dude, it's really hard to just keep this snippet up, I'm scrolling way past it every single time. So, like this junk up here, you can kind of read through it, but usually just skip to the bottom, this is where the juicy bit is usually, but sometimes this can be helpful, but usually I start at the bottom and read up is what helps me. So, it says type string is not assignable to type number or undefined, and so I can see what property it's talking about because it says right here, creator ID is the one, and that's interesting because we just, you know, set this right, so what's going on there? Well, our user ID here, I said it was a string, but it's actually a number, so that that's what I messed up. Um, so that's what's going on there, that's kind of how I look at TypeScript errors, and we can get rid of this any as well. Are there any others that I used? Nope, this one's still fine, but there you go. So, that is how we can handle that case, and with that, we are done with this tutorial. For everyone that made it to the end, thank you for watching. There is one thing we didn't really cover, and that is just deploying the VS Code extension. I'm going to add a link in my description if you want to check out how to do that. VS Code has good documentation on this and you basically just have to set up a couple accounts to actually deploy it to their store, and also I'll put a link of how to deploy the API, if you're interested in deploying that. If you like this video, make sure to give it a thumbs up, I'd really appreciate it, and let me know in the comments below if you enjoyed it. If you did enjoy it, let me know any feedback you have, I really appreciate that, and I hope you guys have an amazing day